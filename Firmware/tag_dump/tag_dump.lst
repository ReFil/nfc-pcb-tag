
tag_dump.elf:     file format elf32-littleriscv


Disassembly of section .init:

00000000 <InterruptVector>:
void handle_reset( void ) __attribute__((section(".text.handle_reset")));

void InterruptVectorDefault( void )
{
#if !defined(FUNCONF_TINYVECTOR) || !FUNCONF_TINYVECTOR
	asm volatile( DEFAULT_INTERRUPT_VECTOR_CONTENTS );
   0:	5e10006f          	j	de0 <handle_reset>
   4:	0000                	unimp
   6:	0000                	unimp
   8:	047c                	addi	a5,sp,524
   a:	0000                	unimp
   c:	0430                	addi	a2,sp,520
	...
  2e:	0000                	unimp
  30:	0430                	addi	a2,sp,520
  32:	0000                	unimp
  34:	0000                	unimp
  36:	0000                	unimp
  38:	0430                	addi	a2,sp,520
  3a:	0000                	unimp
  3c:	0000                	unimp
  3e:	0000                	unimp
  40:	0430                	addi	a2,sp,520
  42:	0000                	unimp
  44:	0430                	addi	a2,sp,520
  46:	0000                	unimp
  48:	0430                	addi	a2,sp,520
  4a:	0000                	unimp
  4c:	0430                	addi	a2,sp,520
  4e:	0000                	unimp
  50:	0430                	addi	a2,sp,520
  52:	0000                	unimp
  54:	0430                	addi	a2,sp,520
  56:	0000                	unimp
  58:	0430                	addi	a2,sp,520
  5a:	0000                	unimp
  5c:	0430                	addi	a2,sp,520
  5e:	0000                	unimp
  60:	0430                	addi	a2,sp,520
  62:	0000                	unimp
  64:	0430                	addi	a2,sp,520
  66:	0000                	unimp
  68:	0430                	addi	a2,sp,520
  6a:	0000                	unimp
  6c:	0430                	addi	a2,sp,520
  6e:	0000                	unimp
  70:	0430                	addi	a2,sp,520
  72:	0000                	unimp
  74:	0430                	addi	a2,sp,520
  76:	0000                	unimp
  78:	0430                	addi	a2,sp,520
  7a:	0000                	unimp
  7c:	0430                	addi	a2,sp,520
  7e:	0000                	unimp
  80:	0430                	addi	a2,sp,520
  82:	0000                	unimp
  84:	0430                	addi	a2,sp,520
  86:	0000                	unimp
  88:	0430                	addi	a2,sp,520
  8a:	0000                	unimp
  8c:	0430                	addi	a2,sp,520
  8e:	0000                	unimp
  90:	0430                	addi	a2,sp,520
  92:	0000                	unimp
  94:	0430                	addi	a2,sp,520
  96:	0000                	unimp
  98:	0430                	addi	a2,sp,520
  9a:	0000                	unimp
  9c:	0000                	unimp
	...

Disassembly of section .text:

000000a0 <__divsi3>:
  a0:	02054e63          	bltz	a0,dc <__umodsi3+0x8>
  a4:	0405c363          	bltz	a1,ea <__umodsi3+0x16>

000000a8 <__hidden___udivsi3>:
  a8:	862e                	mv	a2,a1
  aa:	85aa                	mv	a1,a0
  ac:	557d                	li	a0,-1
  ae:	c215                	beqz	a2,d2 <__hidden___udivsi3+0x2a>
  b0:	4685                	li	a3,1
  b2:	00b67863          	bgeu	a2,a1,c2 <__hidden___udivsi3+0x1a>
  b6:	00c05663          	blez	a2,c2 <__hidden___udivsi3+0x1a>
  ba:	0606                	slli	a2,a2,0x1
  bc:	0686                	slli	a3,a3,0x1
  be:	feb66ce3          	bltu	a2,a1,b6 <__hidden___udivsi3+0xe>
  c2:	4501                	li	a0,0
  c4:	00c5e463          	bltu	a1,a2,cc <__hidden___udivsi3+0x24>
  c8:	8d91                	sub	a1,a1,a2
  ca:	8d55                	or	a0,a0,a3
  cc:	8285                	srli	a3,a3,0x1
  ce:	8205                	srli	a2,a2,0x1
  d0:	faf5                	bnez	a3,c4 <__hidden___udivsi3+0x1c>
  d2:	8082                	ret

000000d4 <__umodsi3>:
  d4:	8286                	mv	t0,ra
  d6:	3fc9                	jal	a8 <__hidden___udivsi3>
  d8:	852e                	mv	a0,a1
  da:	8282                	jr	t0
  dc:	40a00533          	neg	a0,a0
  e0:	00b04763          	bgtz	a1,ee <__umodsi3+0x1a>
  e4:	40b005b3          	neg	a1,a1
  e8:	b7c1                	j	a8 <__hidden___udivsi3>
  ea:	40b005b3          	neg	a1,a1
  ee:	8286                	mv	t0,ra
  f0:	3f65                	jal	a8 <__hidden___udivsi3>
  f2:	40a00533          	neg	a0,a0
  f6:	8282                	jr	t0

000000f8 <__modsi3>:
  f8:	8286                	mv	t0,ra
  fa:	0005c763          	bltz	a1,108 <__modsi3+0x10>
  fe:	00054963          	bltz	a0,110 <__modsi3+0x18>
 102:	375d                	jal	a8 <__hidden___udivsi3>
 104:	852e                	mv	a0,a1
 106:	8282                	jr	t0
 108:	40b005b3          	neg	a1,a1
 10c:	fe055be3          	bgez	a0,102 <__modsi3+0xa>
 110:	40a00533          	neg	a0,a0
 114:	3f51                	jal	a8 <__hidden___udivsi3>
 116:	40b00533          	neg	a0,a1
 11a:	8282                	jr	t0
	...

0000011e <internal_handle_input.constprop.0>:
void handle_debug_input( int numbytes, uint8_t * data ) __attribute__((weak));
void handle_debug_input( int numbytes, uint8_t * data ) { (void)numbytes; (void)data; }

static void internal_handle_input( volatile uint32_t * dmdata0 )
{
	uint32_t dmd0 = *dmdata0;
 11e:	e00007b7          	lui	a5,0xe0000
 122:	0f47a783          	lw	a5,244(a5) # e00000f4 <__global_pointer$+0xbffff8f4>
	int bytes = (dmd0 & 0x3f) - 4;
	if( bytes > 0 && bytes < 16 )
	{
		handle_debug_input( bytes, ((uint8_t*)dmdata0) + 1 );
	}
}
 126:	8082                	ret

00000128 <_write.constprop.0>:
//     status word = 0xcx = timed out.
// declare as weak to allow overriding.
WEAK int _write(int fd, const char *buf, int size)
{
	(void)fd;
	if( ( *DMDATA0 & 0xc0 ) == 0xc0 ) return 0;
 128:	e0000737          	lui	a4,0xe0000
 12c:	0f472783          	lw	a5,244(a4) # e00000f4 <__global_pointer$+0xbffff8f4>
WEAK int _write(int fd, const char *buf, int size)
 130:	1121                	addi	sp,sp,-24
 132:	ca06                	sw	ra,20(sp)
 134:	c822                	sw	s0,16(sp)
 136:	c626                	sw	s1,12(sp)
	if( ( *DMDATA0 & 0xc0 ) == 0xc0 ) return 0;
 138:	0c07f793          	andi	a5,a5,192
 13c:	0c000693          	li	a3,192
 140:	0ad78a63          	beq	a5,a3,1f4 <_write.constprop.0+0xcc>

	char buffer[4] = { 0 };
 144:	c402                	sw	zero,8(sp)
 146:	842e                	mv	s0,a1
	int place = 0;
	uint32_t lastdmd;
	uint32_t timeout = FUNCONF_DEBUGPRINTF_TIMEOUT; // Give up after ~120ms

	if( size == 0 )
 148:	e1f1                	bnez	a1,20c <_write.constprop.0+0xe4>
	{
		lastdmd = (*DMDATA0);
 14a:	0f472783          	lw	a5,244(a4)
		if( lastdmd && !(lastdmd&0x80) ) internal_handle_input( (uint32_t*)DMDATA0 );
 14e:	c789                	beqz	a5,158 <_write.constprop.0+0x30>
 150:	0807f793          	andi	a5,a5,128
 154:	e391                	bnez	a5,158 <_write.constprop.0+0x30>
 156:	37e1                	jal	11e <internal_handle_input.constprop.0>

		//buf += tosend;
		place += tosend;
	}
	return size;
}
 158:	40d2                	lw	ra,20(sp)
 15a:	8522                	mv	a0,s0
 15c:	4442                	lw	s0,16(sp)
 15e:	44b2                	lw	s1,12(sp)
 160:	0161                	addi	sp,sp,24
 162:	8082                	ret
		int tosend = size - place;
 164:	409407b3          	sub	a5,s0,s1
 168:	471d                	li	a4,7
 16a:	00f75363          	bge	a4,a5,170 <_write.constprop.0+0x48>
 16e:	479d                	li	a5,7
 170:	00080737          	lui	a4,0x80
 174:	0705                	addi	a4,a4,1
		while( ( lastdmd = (*DMDATA0) ) & 0x80 )
 176:	e0000637          	lui	a2,0xe0000
 17a:	0f462683          	lw	a3,244(a2) # e00000f4 <__global_pointer$+0xbffff8f4>
 17e:	0f460593          	addi	a1,a2,244
 182:	0806f313          	andi	t1,a3,128
 186:	06031163          	bnez	t1,1e8 <_write.constprop.0+0xc0>
		if( lastdmd ) internal_handle_input( (uint32_t*)DMDATA0 );
 18a:	c691                	beqz	a3,196 <_write.constprop.0+0x6e>
 18c:	c22a                	sw	a0,4(sp)
 18e:	c03e                	sw	a5,0(sp)
 190:	3779                	jal	11e <internal_handle_input.constprop.0>
 192:	4512                	lw	a0,4(sp)
 194:	4782                	lw	a5,0(sp)
 196:	0034                	addi	a3,sp,8
		int tosend = size - place;
 198:	470d                	li	a4,3
 19a:	85b6                	mv	a1,a3
		while( t < tosend )
 19c:	04f74e63          	blt	a4,a5,1f8 <_write.constprop.0+0xd0>
		*DMDATA1 = *(uint32_t*)&(buffer[0]);
 1a0:	46a2                	lw	a3,8(sp)
 1a2:	e0000737          	lui	a4,0xe0000
		while( t < tosend && t < 3 )
 1a6:	460d                	li	a2,3
		*DMDATA1 = *(uint32_t*)&(buffer[0]);
 1a8:	0ed72c23          	sw	a3,248(a4) # e00000f8 <__global_pointer$+0xbffff8f8>
 1ac:	009506b3          	add	a3,a0,s1
		t = 0;
 1b0:	4701                	li	a4,0
			buffer[t+1] = buf[t+place];
 1b2:	0006c283          	lbu	t0,0(a3)
 1b6:	0705                	addi	a4,a4,1
 1b8:	00e58333          	add	t1,a1,a4
 1bc:	00530023          	sb	t0,0(t1)
		while( t < tosend && t < 3 )
 1c0:	00e78563          	beq	a5,a4,1ca <_write.constprop.0+0xa2>
 1c4:	0685                	addi	a3,a3,1
 1c6:	fec716e3          	bne	a4,a2,1b2 <_write.constprop.0+0x8a>
		buffer[0] = 0x80 | (tosend + 4);
 1ca:	00478713          	addi	a4,a5,4
 1ce:	f8076713          	ori	a4,a4,-128
 1d2:	00e10423          	sb	a4,8(sp)
		*DMDATA0 = *(uint32_t*)&(buffer[0]);
 1d6:	46a2                	lw	a3,8(sp)
 1d8:	e0000737          	lui	a4,0xe0000
		place += tosend;
 1dc:	94be                	add	s1,s1,a5
		*DMDATA0 = *(uint32_t*)&(buffer[0]);
 1de:	0ed72a23          	sw	a3,244(a4) # e00000f4 <__global_pointer$+0xbffff8f4>
	while( place < size )
 1e2:	f884c1e3          	blt	s1,s0,164 <_write.constprop.0+0x3c>
 1e6:	bf8d                	j	158 <_write.constprop.0+0x30>
 1e8:	177d                	addi	a4,a4,-1
			if( timeout-- == 0 )
 1ea:	fb41                	bnez	a4,17a <_write.constprop.0+0x52>
				*DMDATA0 |= 0xc0;
 1ec:	419c                	lw	a5,0(a1)
 1ee:	0c07e793          	ori	a5,a5,192
 1f2:	c19c                	sw	a5,0(a1)
	if( ( *DMDATA0 & 0xc0 ) == 0xc0 ) return 0;
 1f4:	4401                	li	s0,0
 1f6:	b78d                	j	158 <_write.constprop.0+0x30>
			buffer[t-3] = buf[t+place];
 1f8:	00e48633          	add	a2,s1,a4
 1fc:	962a                	add	a2,a2,a0
 1fe:	00064603          	lbu	a2,0(a2)
			t++;
 202:	0705                	addi	a4,a4,1
 204:	0685                	addi	a3,a3,1
			buffer[t-3] = buf[t+place];
 206:	fec68fa3          	sb	a2,-1(a3)
 20a:	bf49                	j	19c <_write.constprop.0+0x74>
	if( size == 0 )
 20c:	4481                	li	s1,0
 20e:	bfd1                	j	1e2 <_write.constprop.0+0xba>

00000210 <__disable_irq>:
}

// Disable Global Interrupt
RV_STATIC_INLINE void __disable_irq()
{
	uint32_t result; __ASM volatile( ADD_ARCH_ZICSR "csrr %0," "mstatus": "=r"(result) );
 210:	300027f3          	csrr	a5,mstatus
	result &= ~0x88; __ASM volatile( ADD_ARCH_ZICSR "csrw mstatus, %0" : : "r" (result) );
 214:	f777f793          	andi	a5,a5,-137
 218:	30079073          	csrw	mstatus,a5
}
 21c:	8082                	ret

0000021e <__enable_irq>:
	uint32_t result; __ASM volatile( ADD_ARCH_ZICSR "csrr %0," "mstatus": "=r"(result) );
 21e:	300027f3          	csrr	a5,mstatus
	result |= 0x88;  __ASM volatile( ADD_ARCH_ZICSR "csrw mstatus, %0" : : "r" (result) );
 222:	0887e793          	ori	a5,a5,136
 226:	30079073          	csrw	mstatus,a5
}
 22a:	8082                	ret

0000022c <mini_itoa.part.0>:
mini_itoa(long value, unsigned int radix, int uppercase, int unsig,
 22c:	1101                	addi	sp,sp,-32
 22e:	ce06                	sw	ra,28(sp)
 230:	cc22                	sw	s0,24(sp)
 232:	ca26                	sw	s1,20(sp)
	int	negative = 0;
 234:	c002                	sw	zero,0(sp)
mini_itoa(long value, unsigned int radix, int uppercase, int unsig,
 236:	832a                	mv	t1,a0
	if (value < 0 && !unsig) {
 238:	00055763          	bgez	a0,246 <mini_itoa.part.0+0x1a>
 23c:	e689                	bnez	a3,246 <mini_itoa.part.0+0x1a>
		negative = 1;
 23e:	4785                	li	a5,1
		value = -value;
 240:	40a00333          	neg	t1,a0
		negative = 1;
 244:	c03e                	sw	a5,0(sp)
 246:	06100413          	li	s0,97
 24a:	c219                	beqz	a2,250 <mini_itoa.part.0+0x24>
 24c:	04100413          	li	s0,65
	int	negative = 0;
 250:	84ba                	mv	s1,a4
		*(pbuffer++) = (digit < 10 ? '0' + digit : (uppercase ? 'A' : 'a') + digit - 10);
 252:	1459                	addi	s0,s0,-10
		int digit = value % radix;
 254:	851a                	mv	a0,t1
 256:	c83a                	sw	a4,16(sp)
 258:	c21a                	sw	t1,4(sp)
 25a:	c62e                	sw	a1,12(sp)
 25c:	c41a                	sw	t1,8(sp)
 25e:	3d9d                	jal	d4 <__umodsi3>
		*(pbuffer++) = (digit < 10 ? '0' + digit : (uppercase ? 'A' : 'a') + digit - 10);
 260:	47a5                	li	a5,9
 262:	4322                	lw	t1,8(sp)
 264:	45b2                	lw	a1,12(sp)
 266:	4742                	lw	a4,16(sp)
 268:	0ff57693          	andi	a3,a0,255
 26c:	06a7e163          	bltu	a5,a0,2ce <mini_itoa.part.0+0xa2>
 270:	03068693          	addi	a3,a3,48
 274:	0ff6f693          	andi	a3,a3,255
 278:	00148793          	addi	a5,s1,1
 27c:	00d48023          	sb	a3,0(s1)
		value /= radix;
 280:	851a                	mv	a0,t1
 282:	c83a                	sw	a4,16(sp)
		*(pbuffer++) = (digit < 10 ? '0' + digit : (uppercase ? 'A' : 'a') + digit - 10);
 284:	c63e                	sw	a5,12(sp)
		value /= radix;
 286:	c42e                	sw	a1,8(sp)
 288:	3505                	jal	a8 <__hidden___udivsi3>
	} while (value > 0);
 28a:	4692                	lw	a3,4(sp)
 28c:	45a2                	lw	a1,8(sp)
 28e:	47b2                	lw	a5,12(sp)
 290:	4742                	lw	a4,16(sp)
		value /= radix;
 292:	832a                	mv	t1,a0
	} while (value > 0);
 294:	02b6fb63          	bgeu	a3,a1,2ca <mini_itoa.part.0+0x9e>
	if (negative)
 298:	4682                	lw	a3,0(sp)
 29a:	c699                	beqz	a3,2a8 <mini_itoa.part.0+0x7c>
		*(pbuffer++) = '-';
 29c:	02d00693          	li	a3,45
 2a0:	00d78023          	sb	a3,0(a5)
 2a4:	00248793          	addi	a5,s1,2
	len = (pbuffer - buffer);
 2a8:	40e78533          	sub	a0,a5,a4
	for (i = 0; i < len / 2; i++) {
 2ac:	01f55693          	srli	a3,a0,0x1f
 2b0:	96aa                	add	a3,a3,a0
	*(pbuffer) = '\0';
 2b2:	00078023          	sb	zero,0(a5)
	for (i = 0; i < len / 2; i++) {
 2b6:	8685                	srai	a3,a3,0x1
 2b8:	4601                	li	a2,0
 2ba:	17fd                	addi	a5,a5,-1
 2bc:	00d64b63          	blt	a2,a3,2d2 <mini_itoa.part.0+0xa6>
}
 2c0:	40f2                	lw	ra,28(sp)
 2c2:	4462                	lw	s0,24(sp)
 2c4:	44d2                	lw	s1,20(sp)
 2c6:	6105                	addi	sp,sp,32
 2c8:	8082                	ret
	} while (value > 0);
 2ca:	84be                	mv	s1,a5
 2cc:	b761                	j	254 <mini_itoa.part.0+0x28>
		*(pbuffer++) = (digit < 10 ? '0' + digit : (uppercase ? 'A' : 'a') + digit - 10);
 2ce:	96a2                	add	a3,a3,s0
 2d0:	b755                	j	274 <mini_itoa.part.0+0x48>
		char j = buffer[i];
 2d2:	00c705b3          	add	a1,a4,a2
		buffer[i] = buffer[len-i-1];
 2d6:	0007c283          	lbu	t0,0(a5)
		char j = buffer[i];
 2da:	0005c303          	lbu	t1,0(a1)
	for (i = 0; i < len / 2; i++) {
 2de:	0605                	addi	a2,a2,1
		buffer[i] = buffer[len-i-1];
 2e0:	00558023          	sb	t0,0(a1)
		buffer[len-i-1] = j;
 2e4:	00678023          	sb	t1,0(a5)
	for (i = 0; i < len / 2; i++) {
 2e8:	bfc9                	j	2ba <mini_itoa.part.0+0x8e>

000002ea <PrintN>:
	while( (*DMDATA0) & 0x80 );
 2ea:	e0000737          	lui	a4,0xe0000
 2ee:	0f472783          	lw	a5,244(a4) # e00000f4 <__global_pointer$+0xbffff8f4>
 2f2:	0807f793          	andi	a5,a5,128
 2f6:	ffe5                	bnez	a5,2ee <PrintN+0x4>
	*DMDATA0 = 0x78302088; //" 0x"
 2f8:	783027b7          	lui	a5,0x78302
 2fc:	08878793          	addi	a5,a5,136 # 78302088 <__global_pointer$+0x58301888>
 300:	0ef72a23          	sw	a5,244(a4)
		while( (*DMDATA0) & 0x80 );
 304:	e0000637          	lui	a2,0xe0000
	for( shift = 28; shift >= 0; shift -= 4 )
 308:	4771                	li	a4,28
		s += ( s < 10 ) ? '0' : ('a' - 10);
 30a:	4325                	li	t1,9
	for( shift = 28; shift >= 0; shift -= 4 )
 30c:	55f1                	li	a1,-4
		while( (*DMDATA0) & 0x80 );
 30e:	0f462783          	lw	a5,244(a2) # e00000f4 <__global_pointer$+0xbffff8f4>
 312:	0807f793          	andi	a5,a5,128
 316:	ffe5                	bnez	a5,30e <PrintN+0x24>
		int s = (n>>shift) & 0xf;
 318:	00e557b3          	srl	a5,a0,a4
 31c:	00f7f693          	andi	a3,a5,15
		s += ( s < 10 ) ? '0' : ('a' - 10);
 320:	03000793          	li	a5,48
 324:	00d35463          	bge	t1,a3,32c <PrintN+0x42>
 328:	05700793          	li	a5,87
 32c:	97b6                	add	a5,a5,a3
		*DMDATA0 = 0x85 | (s<<8); //" 0x"
 32e:	07a2                	slli	a5,a5,0x8
 330:	0857e793          	ori	a5,a5,133
 334:	0ef62a23          	sw	a5,244(a2)
	for( shift = 28; shift >= 0; shift -= 4 )
 338:	1771                	addi	a4,a4,-4
 33a:	fcb71ae3          	bne	a4,a1,30e <PrintN+0x24>
}
 33e:	8082                	ret

00000340 <mini_pad>:
	int overflow = 0;
 340:	4301                	li	t1,0
	if(pad_to == 0) pad_to = len;
 342:	c2ad                	beqz	a3,3a4 <mini_pad+0x64>
	if(len > pad_to) {
 344:	00b6d463          	bge	a3,a1,34c <mini_pad+0xc>
 348:	85b6                	mv	a1,a3
		overflow = 1;
 34a:	4305                	li	t1,1
	for(i = pad_to - len; i > 0; i --) {
 34c:	8e8d                	sub	a3,a3,a1
 34e:	87ba                	mv	a5,a4
 350:	00d703b3          	add	t2,a4,a3
 354:	40f382b3          	sub	t0,t2,a5
 358:	04504863          	bgtz	t0,3a8 <mini_pad+0x68>
 35c:	0006d363          	bgez	a3,362 <mini_pad+0x22>
 360:	4681                	li	a3,0
 362:	96ba                	add	a3,a3,a4
 364:	4781                	li	a5,0
	for(i = len; i > 0; i --) {
 366:	40f58633          	sub	a2,a1,a5
 36a:	04c04363          	bgtz	a2,3b0 <mini_pad+0x70>
 36e:	0005d363          	bgez	a1,374 <mini_pad+0x34>
 372:	4581                	li	a1,0
 374:	95b6                	add	a1,a1,a3
	len = pbuffer - buffer;
 376:	40e58533          	sub	a0,a1,a4
	if(overflow) {
 37a:	02030463          	beqz	t1,3a2 <mini_pad+0x62>
		for (i = 0; i < 3 && pbuffer > buffer; i ++) {
 37e:	02b77263          	bgeu	a4,a1,3a2 <mini_pad+0x62>
			*(pbuffer-- - 1) = '*';
 382:	02a00793          	li	a5,42
 386:	fef58fa3          	sb	a5,-1(a1)
 38a:	fff58693          	addi	a3,a1,-1
		for (i = 0; i < 3 && pbuffer > buffer; i ++) {
 38e:	00d77a63          	bgeu	a4,a3,3a2 <mini_pad+0x62>
			*(pbuffer-- - 1) = '*';
 392:	fef58f23          	sb	a5,-2(a1)
 396:	ffe58693          	addi	a3,a1,-2
		for (i = 0; i < 3 && pbuffer > buffer; i ++) {
 39a:	00d77463          	bgeu	a4,a3,3a2 <mini_pad+0x62>
			*(pbuffer-- - 1) = '*';
 39e:	fef58ea3          	sb	a5,-3(a1)
}
 3a2:	8082                	ret
	if(pad_to == 0) pad_to = len;
 3a4:	86ae                	mv	a3,a1
 3a6:	b75d                	j	34c <mini_pad+0xc>
		*(pbuffer++) = pad_char;
 3a8:	0785                	addi	a5,a5,1
 3aa:	fec78fa3          	sb	a2,-1(a5)
	for(i = pad_to - len; i > 0; i --) {
 3ae:	b75d                	j	354 <mini_pad+0x14>
		*(pbuffer++) = *(ptr++);
 3b0:	00f50633          	add	a2,a0,a5
 3b4:	00064283          	lbu	t0,0(a2)
 3b8:	00f68633          	add	a2,a3,a5
 3bc:	0785                	addi	a5,a5,1
 3be:	00560023          	sb	t0,0(a2)
	for(i = len; i > 0; i --) {
 3c2:	b755                	j	366 <mini_pad+0x26>

000003c4 <__puts_uart>:
{
 3c4:	1151                	addi	sp,sp,-12
 3c6:	c222                	sw	s0,4(sp)
 3c8:	c406                	sw	ra,8(sp)
 3ca:	842e                	mv	s0,a1
	_write( 0, s, len );
 3cc:	3bb1                	jal	128 <_write.constprop.0>
}
 3ce:	40a2                	lw	ra,8(sp)
 3d0:	8522                	mv	a0,s0
 3d2:	4412                	lw	s0,4(sp)
 3d4:	0131                	addi	sp,sp,12
 3d6:	8082                	ret

000003d8 <SystemInit>:
	#endif
#elif defined(CH32X03x)
	FLASH->ACTLR = FLASH_ACTLR_LATENCY_2;                   // +2 Cycle Latency (Recommended per TRM)
#elif defined(CH32V003)
	#if FUNCONF_SYSTEM_CORE_CLOCK > 25000000
		FLASH->ACTLR = FLASH_ACTLR_LATENCY_1;               // +1 Cycle Latency
 3d8:	400227b7          	lui	a5,0x40022
 3dc:	4705                	li	a4,1
 3de:	c398                	sw	a4,0(a5)
#if defined(FUNCONF_USE_HSI) && FUNCONF_USE_HSI
	#if defined(CH32V30x) || defined(CH32V20x) || defined(CH32V10x)
		EXTEN->EXTEN_CTR |= EXTEN_PLL_HSI_PRE;
	#endif
	#if defined(FUNCONF_USE_PLL) && FUNCONF_USE_PLL
		RCC->CFGR0 = BASE_CFGR0;
 3e0:	400217b7          	lui	a5,0x40021
		RCC->CTLR  = BASE_CTLR | RCC_HSION | RCC_PLLON; 			// Use HSI, enable PLL.
 3e4:	01080737          	lui	a4,0x1080
		RCC->CFGR0 = BASE_CFGR0;
 3e8:	0007a223          	sw	zero,4(a5) # 40021004 <__global_pointer$+0x20020804>
		RCC->CTLR  = BASE_CTLR | RCC_HSION | RCC_PLLON; 			// Use HSI, enable PLL.
 3ec:	08170713          	addi	a4,a4,129 # 1080081 <lib_i2c.c.01c03b19+0x107c335>
 3f0:	c398                	sw	a4,0(a5)
	#else
		FLASH->ACTLR = FLASH_ACTLR_LATENCY_1;       		// +1 Cycle Latency
	#endif
#endif

	RCC->INTR  = 0x009F0000;                               // Clear PLL, CSSC, HSE, HSI and LSI ready flags.
 3f2:	009f0737          	lui	a4,0x9f0
 3f6:	c798                	sw	a4,8(a5)

#if defined(FUNCONF_USE_PLL) && FUNCONF_USE_PLL
	while((RCC->CTLR & RCC_PLLRDY) == 0);                       	// Wait till PLL is ready
 3f8:	40021737          	lui	a4,0x40021
 3fc:	431c                	lw	a5,0(a4)
 3fe:	00679693          	slli	a3,a5,0x6
 402:	fe06dde3          	bgez	a3,3fc <SystemInit+0x24>
	uint32_t tmp32 = RCC->CFGR0 & ~(0x03);							// clr the SW
 406:	435c                	lw	a5,4(a4)
	RCC->CFGR0 = tmp32 | RCC_SW_PLL;                       			// Select PLL as system clock source
	while ((RCC->CFGR0 & (uint32_t)RCC_SWS) != (uint32_t)0x08); 	// Wait till PLL is used as system clock source
 408:	400216b7          	lui	a3,0x40021
	uint32_t tmp32 = RCC->CFGR0 & ~(0x03);							// clr the SW
 40c:	9bf1                	andi	a5,a5,-4
	RCC->CFGR0 = tmp32 | RCC_SW_PLL;                       			// Select PLL as system clock source
 40e:	0027e793          	ori	a5,a5,2
 412:	c35c                	sw	a5,4(a4)
	while ((RCC->CFGR0 & (uint32_t)RCC_SWS) != (uint32_t)0x08); 	// Wait till PLL is used as system clock source
 414:	4721                	li	a4,8
 416:	42dc                	lw	a5,4(a3)
 418:	8bb1                	andi	a5,a5,12
 41a:	fee79ee3          	bne	a5,a4,416 <SystemInit+0x3e>
	*DMDATA1 = 0x00;
 41e:	e00007b7          	lui	a5,0xe0000
 422:	0e07ac23          	sw	zero,248(a5) # e00000f8 <__global_pointer$+0xbffff8f8>
	*DMDATA0 = 0x80;
 426:	08000713          	li	a4,128
 42a:	0ee7aa23          	sw	a4,244(a5)
	SetupUART( UART_BRR );
#endif
#if defined( FUNCONF_USE_DEBUGPRINTF ) && FUNCONF_USE_DEBUGPRINTF
	SetupDebugPrintf();
#endif
}
 42e:	8082                	ret

00000430 <ADC1_2_IRQHandler>:

// Return the Machine Exception Program Register (MEPC)
static inline uint32_t __get_MEPC(void)
{
	uint32_t result;
	__ASM volatile( ADD_ARCH_ZICSR "csrr %0," "mepc" : "=r"(result));
 430:	34102573          	csrr	a0,mepc
	PrintN( __get_MEPC() ); // "addr2line -e debugprintfdemo.elf 0x000007e6" ---> debugprintfdemo.c:45
 434:	3d5d                	jal	2ea <PrintN>
	__ASM volatile( ADD_ARCH_ZICSR "csrr %0, mstatus": "=r"(result) );
 436:	30002573          	csrr	a0,mstatus
	PrintN( __get_MSTATUS() );
 43a:	3d45                	jal	2ea <PrintN>

// Return the Machine Trap Value Register (MTVAL)
static inline uint32_t __get_MTVAL(void)
{
	uint32_t result;
	__ASM volatile( ADD_ARCH_ZICSR "csrr %0," "mtval" : "=r" (result) );
 43c:	34302573          	csrr	a0,mtval
	PrintN( __get_MTVAL() );
 440:	356d                	jal	2ea <PrintN>
	__ASM volatile( ADD_ARCH_ZICSR "csrr %0," "mcause": "=r"(result));
 442:	34202573          	csrr	a0,mcause
	PrintN( __get_MCAUSE() );
 446:	3555                	jal	2ea <PrintN>
	while( (*DMDATA0) & 0x80 );
 448:	e0000737          	lui	a4,0xe0000
 44c:	0f472783          	lw	a5,244(a4) # e00000f4 <__global_pointer$+0xbffff8f4>
 450:	0807f793          	andi	a5,a5,128
 454:	ffe5                	bnez	a5,44c <ADC1_2_IRQHandler+0x1c>
	*DMDATA0 = 0x0a85;
 456:	6785                	lui	a5,0x1
 458:	a8578793          	addi	a5,a5,-1403 # a85 <main+0x3df>
 45c:	0ef72a23          	sw	a5,244(a4)
	while( (*DMDATA0) & 0x80 );
 460:	e0000737          	lui	a4,0xe0000
 464:	0f472783          	lw	a5,244(a4) # e00000f4 <__global_pointer$+0xbffff8f4>
 468:	0807f793          	andi	a5,a5,128
 46c:	ffe5                	bnez	a5,464 <ADC1_2_IRQHandler+0x34>
	*DMDATA0 = 0xaaaaaa83;
 46e:	aaaab7b7          	lui	a5,0xaaaab
 472:	a8378793          	addi	a5,a5,-1405 # aaaaaa83 <__global_pointer$+0x8aaaa283>
 476:	0ef72a23          	sw	a5,244(a4)
	asm volatile( "1: j 1b" );
 47a:	a001                	j	47a <ADC1_2_IRQHandler+0x4a>

0000047c <NMI_Handler>:
	RCC->INTR |= RCC_CSSC;	// clear the clock security int flag
 47c:	40021737          	lui	a4,0x40021
 480:	471c                	lw	a5,8(a4)
 482:	008006b7          	lui	a3,0x800
 486:	8fd5                	or	a5,a5,a3
 488:	c71c                	sw	a5,8(a4)

0000048a <strlen>:
{
 48a:	87aa                	mv	a5,a0
	for (; *s; s++);
 48c:	0007c703          	lbu	a4,0(a5)
 490:	e701                	bnez	a4,498 <strlen+0xe>
}
 492:	40a78533          	sub	a0,a5,a0
 496:	8082                	ret
	for (; *s; s++);
 498:	0785                	addi	a5,a5,1
 49a:	bfcd                	j	48c <strlen+0x2>

0000049c <mini_vpprintf>:
{
 49c:	fa410113          	addi	sp,sp,-92
 4a0:	c8a6                	sw	s1,80(sp)
 4a2:	cc86                	sw	ra,88(sp)
 4a4:	caa2                	sw	s0,84(sp)
 4a6:	c02a                	sw	a0,0(sp)
 4a8:	c22e                	sw	a1,4(sp)
 4aa:	84b2                	mv	s1,a2
 4ac:	87b6                	mv	a5,a3
	int n = 0;
 4ae:	c802                	sw	zero,16(sp)
	while ((ch=*(fmt++))) {
 4b0:	0004c703          	lbu	a4,0(s1)
 4b4:	00148413          	addi	s0,s1,1
 4b8:	00e10fa3          	sb	a4,31(sp)
 4bc:	eb01                	bnez	a4,4cc <mini_vpprintf+0x30>
}
 4be:	40e6                	lw	ra,88(sp)
 4c0:	4456                	lw	s0,84(sp)
 4c2:	4542                	lw	a0,16(sp)
 4c4:	44c6                	lw	s1,80(sp)
 4c6:	05c10113          	addi	sp,sp,92
 4ca:	8082                	ret
		if (ch!='%') {
 4cc:	02500693          	li	a3,37
 4d0:	00d70f63          	beq	a4,a3,4ee <mini_vpprintf+0x52>
 4d4:	c43e                	sw	a5,8(sp)
			len = puts(&ch, len, buf);
 4d6:	4612                	lw	a2,4(sp)
 4d8:	4782                	lw	a5,0(sp)
 4da:	4585                	li	a1,1
 4dc:	01f10513          	addi	a0,sp,31
 4e0:	9782                	jalr	a5
	while ((ch=*(fmt++))) {
 4e2:	84a2                	mv	s1,s0
		n = n + len;
 4e4:	47c2                	lw	a5,16(sp)
 4e6:	97aa                	add	a5,a5,a0
 4e8:	c83e                	sw	a5,16(sp)
 4ea:	47a2                	lw	a5,8(sp)
 4ec:	b7d1                	j	4b0 <mini_vpprintf+0x14>
			ch=*(fmt++);
 4ee:	0014c683          	lbu	a3,1(s1)
			if (ch == '0') pad_char = '0';
 4f2:	03000613          	li	a2,48
			ch=*(fmt++);
 4f6:	00248713          	addi	a4,s1,2
 4fa:	00d10fa3          	sb	a3,31(sp)
			if (ch == '0') pad_char = '0';
 4fe:	03000413          	li	s0,48
 502:	08c69063          	bne	a3,a2,582 <mini_vpprintf+0xe6>
				ch=*(fmt++);
 506:	84ba                	mv	s1,a4
 508:	4601                	li	a2,0
 50a:	4701                	li	a4,0
			while (ch >= '0' && ch <= '9') {
 50c:	4525                	li	a0,9
 50e:	a811                	j	522 <mini_vpprintf+0x86>
				pad_to = pad_to * 10 + (ch - '0');
 510:	00271693          	slli	a3,a4,0x2
				ch=*(fmt++);
 514:	0485                	addi	s1,s1,1
				pad_to = pad_to * 10 + (ch - '0');
 516:	9736                	add	a4,a4,a3
				ch=*(fmt++);
 518:	fff4c683          	lbu	a3,-1(s1)
				pad_to = pad_to * 10 + (ch - '0');
 51c:	0706                	slli	a4,a4,0x1
 51e:	972e                	add	a4,a4,a1
				ch=*(fmt++);
 520:	4605                	li	a2,1
			while (ch >= '0' && ch <= '9') {
 522:	fd068593          	addi	a1,a3,-48 # 7fffd0 <lib_i2c.c.01c03b19+0x7fc284>
 526:	0ff5f313          	andi	t1,a1,255
 52a:	fe6573e3          	bgeu	a0,t1,510 <mini_vpprintf+0x74>
 52e:	c219                	beqz	a2,534 <mini_vpprintf+0x98>
 530:	00d10fa3          	sb	a3,31(sp)
			if(pad_to > (signed int) sizeof(bf)) {
 534:	c63a                	sw	a4,12(sp)
 536:	4661                	li	a2,24
 538:	00e65363          	bge	a2,a4,53e <mini_vpprintf+0xa2>
 53c:	c632                	sw	a2,12(sp)
			if (ch == 'l') {
 53e:	06c00593          	li	a1,108
			char l = 0;
 542:	4601                	li	a2,0
			if (ch == 'l') {
 544:	00b69863          	bne	a3,a1,554 <mini_vpprintf+0xb8>
				ch=*(fmt++);
 548:	0004c683          	lbu	a3,0(s1)
				l = 1;
 54c:	4605                	li	a2,1
				ch=*(fmt++);
 54e:	0485                	addi	s1,s1,1
 550:	00d10fa3          	sb	a3,31(sp)
			switch (ch) {
 554:	01f14683          	lbu	a3,31(sp)
 558:	06400593          	li	a1,100
 55c:	06b68363          	beq	a3,a1,5c2 <mini_vpprintf+0x126>
 560:	02d5e463          	bltu	a1,a3,588 <mini_vpprintf+0xec>
 564:	05800713          	li	a4,88
 568:	0ae68063          	beq	a3,a4,608 <mini_vpprintf+0x16c>
 56c:	06300713          	li	a4,99
 570:	0ae68d63          	beq	a3,a4,62a <mini_vpprintf+0x18e>
 574:	d6a9                	beqz	a3,4be <mini_vpprintf+0x22>
					len = puts(&ch, len, buf);
 576:	4612                	lw	a2,4(sp)
 578:	c43e                	sw	a5,8(sp)
 57a:	4585                	li	a1,1
 57c:	01f10513          	addi	a0,sp,31
 580:	a0bd                	j	5ee <mini_vpprintf+0x152>
			char pad_char = ' ';
 582:	02000413          	li	s0,32
 586:	b741                	j	506 <mini_vpprintf+0x6a>
			switch (ch) {
 588:	07500593          	li	a1,117
 58c:	02b68b63          	beq	a3,a1,5c2 <mini_vpprintf+0x126>
 590:	07800613          	li	a2,120
 594:	06c68a63          	beq	a3,a2,608 <mini_vpprintf+0x16c>
 598:	07300613          	li	a2,115
 59c:	fcc69de3          	bne	a3,a2,576 <mini_vpprintf+0xda>
 5a0:	cc3a                	sw	a4,24(sp)
					ptr = va_arg(va, char*);
 5a2:	00478713          	addi	a4,a5,4
 5a6:	439c                	lw	a5,0(a5)
 5a8:	c43a                	sw	a4,8(sp)
					len = mini_strlen(ptr);
 5aa:	853e                	mv	a0,a5
 5ac:	ca3e                	sw	a5,20(sp)
 5ae:	3df1                	jal	48a <strlen>
					if (pad_to > 0) {
 5b0:	4762                	lw	a4,24(sp)
 5b2:	47d2                	lw	a5,20(sp)
					len = mini_strlen(ptr);
 5b4:	85aa                	mv	a1,a0
					if (pad_to > 0) {
 5b6:	c759                	beqz	a4,644 <mini_vpprintf+0x1a8>
						len = mini_pad(ptr, len, pad_char, pad_to, bf);
 5b8:	46b2                	lw	a3,12(sp)
 5ba:	1838                	addi	a4,sp,56
 5bc:	8622                	mv	a2,s0
 5be:	853e                	mv	a0,a5
 5c0:	a01d                	j	5e6 <mini_vpprintf+0x14a>
					if(l) {
 5c2:	00478713          	addi	a4,a5,4
 5c6:	c43a                	sw	a4,8(sp)
 5c8:	c615                	beqz	a2,5f4 <mini_vpprintf+0x158>
						len = mini_itoa(va_arg(va, unsigned long), 10, 0, (ch=='u'), bf2);
 5ca:	f8b68693          	addi	a3,a3,-117
 5ce:	1018                	addi	a4,sp,32
 5d0:	0016b693          	seqz	a3,a3
 5d4:	4388                	lw	a0,0(a5)
 5d6:	4601                	li	a2,0
 5d8:	45a9                	li	a1,10
 5da:	3989                	jal	22c <mini_itoa.part.0>
					len = mini_pad(bf2, len, pad_char, pad_to, bf);
 5dc:	46b2                	lw	a3,12(sp)
 5de:	1838                	addi	a4,sp,56
 5e0:	8622                	mv	a2,s0
 5e2:	85aa                	mv	a1,a0
					len = mini_pad(bf2, len, pad_char, pad_to, bf);
 5e4:	1008                	addi	a0,sp,32
 5e6:	3ba9                	jal	340 <mini_pad>
					len = puts(bf, len, buf);
 5e8:	4612                	lw	a2,4(sp)
					len = mini_pad(bf2, len, pad_char, pad_to, bf);
 5ea:	85aa                	mv	a1,a0
					len = puts(bf, len, buf);
 5ec:	1828                	addi	a0,sp,56
					len = puts(&ch, len, buf);
 5ee:	4782                	lw	a5,0(sp)
 5f0:	9782                	jalr	a5
					break;
 5f2:	bdcd                	j	4e4 <mini_vpprintf+0x48>
						if(ch == 'u') {
 5f4:	07500713          	li	a4,117
 5f8:	00e69563          	bne	a3,a4,602 <mini_vpprintf+0x166>
	if (radix > 16)
 5fc:	1018                	addi	a4,sp,32
 5fe:	4685                	li	a3,1
 600:	bfd1                	j	5d4 <mini_vpprintf+0x138>
 602:	1018                	addi	a4,sp,32
 604:	4681                	li	a3,0
 606:	b7f9                	j	5d4 <mini_vpprintf+0x138>
					if(l) {
 608:	4388                	lw	a0,0(a5)
 60a:	00478713          	addi	a4,a5,4
 60e:	fa868613          	addi	a2,a3,-88
 612:	c43a                	sw	a4,8(sp)
	if (radix > 16)
 614:	4685                	li	a3,1
 616:	1018                	addi	a4,sp,32
 618:	00163613          	seqz	a2,a2
 61c:	45c1                	li	a1,16
 61e:	3139                	jal	22c <mini_itoa.part.0>
					len = mini_pad(bf2, len, pad_char, pad_to, bf);
 620:	46b2                	lw	a3,12(sp)
 622:	85aa                	mv	a1,a0
 624:	1838                	addi	a4,sp,56
 626:	8622                	mv	a2,s0
 628:	bf75                	j	5e4 <mini_vpprintf+0x148>
					ch = (char)(va_arg(va, int));
 62a:	00478713          	addi	a4,a5,4
 62e:	439c                	lw	a5,0(a5)
 630:	c43a                	sw	a4,8(sp)
					len = mini_pad(&ch, 1, pad_char, pad_to, bf);
 632:	46b2                	lw	a3,12(sp)
					ch = (char)(va_arg(va, int));
 634:	00f10fa3          	sb	a5,31(sp)
					len = mini_pad(&ch, 1, pad_char, pad_to, bf);
 638:	1838                	addi	a4,sp,56
 63a:	8622                	mv	a2,s0
 63c:	4585                	li	a1,1
 63e:	01f10513          	addi	a0,sp,31
 642:	b755                	j	5e6 <mini_vpprintf+0x14a>
						len = puts(ptr, len, buf);
 644:	4612                	lw	a2,4(sp)
 646:	853e                	mv	a0,a5
 648:	b75d                	j	5ee <mini_vpprintf+0x152>

0000064a <puts>:
{
 64a:	1151                	addi	sp,sp,-12
 64c:	c406                	sw	ra,8(sp)
 64e:	c222                	sw	s0,4(sp)
 650:	c026                	sw	s1,0(sp)
 652:	84aa                	mv	s1,a0
	int sl = strlen( s );
 654:	3d1d                	jal	48a <strlen>
 656:	842a                	mv	s0,a0
	_write(0, s, sl );
 658:	85aa                	mv	a1,a0
 65a:	8526                	mv	a0,s1
 65c:	34f1                	jal	128 <_write.constprop.0>
	_write(0, "\n", 1 );
 65e:	6505                	lui	a0,0x1
 660:	4585                	li	a1,1
 662:	e5850513          	addi	a0,a0,-424 # e58 <handle_reset+0x78>
 666:	34c9                	jal	128 <_write.constprop.0>
}
 668:	40a2                	lw	ra,8(sp)
 66a:	00140513          	addi	a0,s0,1
 66e:	4412                	lw	s0,4(sp)
 670:	4482                	lw	s1,0(sp)
 672:	0131                	addi	sp,sp,12
 674:	8082                	ret

00000676 <printf>:
{
 676:	fdc10113          	addi	sp,sp,-36
 67a:	ca32                	sw	a2,20(sp)
	int ret_status = mini_vpprintf(__puts_uart, 0, format, args);
 67c:	862a                	mv	a2,a0
{
 67e:	c82e                	sw	a1,16(sp)
 680:	cc36                	sw	a3,24(sp)
	int ret_status = mini_vpprintf(__puts_uart, 0, format, args);
 682:	4581                	li	a1,0
	va_start( args, format );
 684:	0814                	addi	a3,sp,16
	int ret_status = mini_vpprintf(__puts_uart, 0, format, args);
 686:	3c400513          	li	a0,964
{
 68a:	c606                	sw	ra,12(sp)
 68c:	ce3a                	sw	a4,28(sp)
 68e:	d03e                	sw	a5,32(sp)
	va_start( args, format );
 690:	c036                	sw	a3,0(sp)
	int ret_status = mini_vpprintf(__puts_uart, 0, format, args);
 692:	3529                	jal	49c <mini_vpprintf>
}
 694:	40b2                	lw	ra,12(sp)
 696:	02410113          	addi	sp,sp,36
 69a:	8082                	ret

0000069c <i2c_scan_callback>:

void read_and_dump_tag();


void i2c_scan_callback(const uint8_t addr)
{
 69c:	85aa                	mv	a1,a0
	printf("Address: 0x%02X Responded.\n", addr);
 69e:	6505                	lui	a0,0x1
 6a0:	e5c50513          	addi	a0,a0,-420 # e5c <handle_reset+0x7c>
 6a4:	bfc9                	j	676 <printf>

000006a6 <main>:
}


int main()
{
 6a6:	1101                	addi	sp,sp,-32
 6a8:	ce06                	sw	ra,28(sp)
 6aa:	cc22                	sw	s0,24(sp)
 6ac:	ca26                	sw	s1,20(sp)
	SystemInit();
 6ae:	332d                	jal	3d8 <SystemInit>

	RCC->CFGR0 |= (12<<4); //slowdown for lower power
 6b0:	400217b7          	lui	a5,0x40021
 6b4:	43d8                	lw	a4,4(a5)

/*** API Functions ***********************************************************/
i2c_err_t i2c_init(uint32_t clk_rate)
{
	// Toggle the I2C Reset bit to init Registers
	RCC->APB1PRSTR |=  RCC_APB1Periph_I2C1;
 6b6:	002005b7          	lui	a1,0x200
	RCC->APB1PRSTR &= ~RCC_APB1Periph_I2C1;
 6ba:	ffe00637          	lui	a2,0xffe00
 6be:	0c076713          	ori	a4,a4,192
 6c2:	c3d8                	sw	a4,4(a5)

	// Enable GPIOD and ADC for capsense
	RCC->APB2PCENR |= RCC_APB2Periph_GPIOD | RCC_APB2Periph_ADC1;
 6c4:	4f98                	lw	a4,24(a5)
 6c6:	167d                	addi	a2,a2,-1
 6c8:	22076713          	ori	a4,a4,544
 6cc:	cf98                	sw	a4,24(a5)
	RCC->APB1PRSTR |=  RCC_APB1Periph_I2C1;
 6ce:	4b94                	lw	a3,16(a5)
 6d0:	8ecd                	or	a3,a3,a1
 6d2:	cb94                	sw	a3,16(a5)
	RCC->APB1PRSTR &= ~RCC_APB1Periph_I2C1;
 6d4:	4b94                	lw	a3,16(a5)
 6d6:	8ef1                	and	a3,a3,a2
 6d8:	cb94                	sw	a3,16(a5)

	// Enable the I2C Peripheral Clock
	RCC->APB1PCENR |= RCC_APB1Periph_I2C1;
 6da:	4fd8                	lw	a4,28(a5)

	// Enable the selected I2C Port, and the Alternate Function enable bit
	RCC->APB2PCENR |= I2C_PORT_RCC | RCC_APB2Periph_AFIO;

	// Reset the AFIO_PCFR1 register, then set it up
	AFIO->PCFR1 &= ~(0x04400002);
 6dc:	fbc006b7          	lui	a3,0xfbc00
 6e0:	16f5                	addi	a3,a3,-3
	RCC->APB1PCENR |= RCC_APB1Periph_I2C1;
 6e2:	8f4d                	or	a4,a4,a1
 6e4:	cfd8                	sw	a4,28(a5)
	RCC->APB2PCENR |= I2C_PORT_RCC | RCC_APB2Periph_AFIO;
 6e6:	4f98                	lw	a4,24(a5)
 6e8:	01176713          	ori	a4,a4,17
 6ec:	cf98                	sw	a4,24(a5)
	AFIO->PCFR1 &= ~(0x04400002);
 6ee:	400107b7          	lui	a5,0x40010
 6f2:	43d8                	lw	a4,4(a5)
 6f4:	8f75                	and	a4,a4,a3
 6f6:	c3d8                	sw	a4,4(a5)
	AFIO->PCFR1 |= I2C_AFIO_REG;
 6f8:	43d8                	lw	a4,4(a5)

	// Clear, then set the GPIO Settings for SCL and SDA, on the selected port
	I2C_PORT->CFGLR &= ~(0x0F << (4 * I2C_PIN_SDA));
	I2C_PORT->CFGLR |= (GPIO_Speed_10MHz | GPIO_CNF_OUT_OD_AF) << (4 * I2C_PIN_SDA);	
	I2C_PORT->CFGLR &= ~(0x0F << (4 * I2C_PIN_SCL));
 6fa:	76fd                	lui	a3,0xfffff
 6fc:	0ff68693          	addi	a3,a3,255 # fffff0ff <__global_pointer$+0xdfffe8ff>
	AFIO->PCFR1 |= I2C_AFIO_REG;
 700:	c3d8                	sw	a4,4(a5)
	I2C_PORT->CFGLR &= ~(0x0F << (4 * I2C_PIN_SDA));
 702:	400117b7          	lui	a5,0x40011
 706:	4398                	lw	a4,0(a5)
 708:	f0f77713          	andi	a4,a4,-241
 70c:	c398                	sw	a4,0(a5)
	I2C_PORT->CFGLR |= (GPIO_Speed_10MHz | GPIO_CNF_OUT_OD_AF) << (4 * I2C_PIN_SDA);	
 70e:	4398                	lw	a4,0(a5)
 710:	0d076713          	ori	a4,a4,208
 714:	c398                	sw	a4,0(a5)
	I2C_PORT->CFGLR &= ~(0x0F << (4 * I2C_PIN_SCL));
 716:	4398                	lw	a4,0(a5)
 718:	8f75                	and	a4,a4,a3
 71a:	c398                	sw	a4,0(a5)
	I2C_PORT->CFGLR |= (GPIO_Speed_10MHz | GPIO_CNF_OUT_OD_AF) << (4 * I2C_PIN_SCL);
 71c:	4398                	lw	a4,0(a5)
 71e:	6685                	lui	a3,0x1
 720:	d0068693          	addi	a3,a3,-768 # d00 <main+0x65a>
 724:	8f55                	or	a4,a4,a3
 726:	c398                	sw	a4,0(a5)

	// Set the Prerate frequency
	uint16_t i2c_conf = I2C1->CTLR2 & ~I2C_CTLR2_FREQ;
 728:	400056b7          	lui	a3,0x40005
 72c:	4046d783          	lhu	a5,1028(a3) # 40005404 <__global_pointer$+0x20004c04>
 730:	07c2                	slli	a5,a5,0x10
 732:	83c1                	srli	a5,a5,0x10
 734:	fc07f793          	andi	a5,a5,-64
	i2c_conf |= (FUNCONF_SYSTEM_CORE_CLOCK / I2C_PRERATE) & I2C_CTLR2_FREQ;
 738:	0307e793          	ori	a5,a5,48
	I2C1->CTLR2 = i2c_conf;
 73c:	40f69223          	sh	a5,1028(a3)
	} else {
		// Fast mode. Default to 33% Duty Cycle
		i2c_conf = (FUNCONF_SYSTEM_CORE_CLOCK / (3 * clk_rate)) & I2C_CKCFGR_CCR;
		i2c_conf |= I2C_CKCFGR_FS;
	}
	I2C1->CKCFGR = i2c_conf;
 740:	77e1                	lui	a5,0xffff8
 742:	02878793          	addi	a5,a5,40 # ffff8028 <__global_pointer$+0xdfff7828>
 746:	40f69e23          	sh	a5,1052(a3)

	// Enable the I2C Peripheral
	I2C1->CTLR1 |= I2C_CTLR1_PE;
 74a:	4006d783          	lhu	a5,1024(a3)
 74e:	07c2                	slli	a5,a5,0x10
 750:	83c1                	srli	a5,a5,0x10
 752:	0017e793          	ori	a5,a5,1
 756:	40f69023          	sh	a5,1024(a3)

	//TODO:
	// Check error states
	if(I2C1->STAR1 & I2C_STAR1_BERR) 
 75a:	4146d783          	lhu	a5,1044(a3)
 75e:	1007f793          	andi	a5,a5,256
 762:	cf99                	beqz	a5,780 <main+0xda>
	{
		I2C1->STAR1 &= ~(I2C_STAR1_BERR); 
 764:	4146d783          	lhu	a5,1044(a3)


	if(i2c_init(I2C_CLK_400KHZ) != I2C_OK) printf("Failed to init the I2C Bus\n");
 768:	6505                	lui	a0,0x1
 76a:	e7850513          	addi	a0,a0,-392 # e78 <handle_reset+0x98>
 76e:	07c2                	slli	a5,a5,0x10
 770:	83c1                	srli	a5,a5,0x10
 772:	eff7f793          	andi	a5,a5,-257
 776:	07c2                	slli	a5,a5,0x10
 778:	83c1                	srli	a5,a5,0x10
 77a:	40f69a23          	sh	a5,1044(a3)
 77e:	35f1                	jal	64a <puts>
	uint32_t targend = SysTick->CNT + n;
 780:	e000f7b7          	lui	a5,0xe000f
 784:	4798                	lw	a4,8(a5)
 786:	004947b7          	lui	a5,0x494
 78a:	e0078793          	addi	a5,a5,-512 # 493e00 <lib_i2c.c.01c03b19+0x4900b4>
 78e:	973e                	add	a4,a4,a5
	while( ((int32_t)( SysTick->CNT - targend )) < 0 );
 790:	e000f6b7          	lui	a3,0xe000f
 794:	469c                	lw	a5,8(a3)
 796:	8f99                	sub	a5,a5,a4
 798:	fe07cee3          	bltz	a5,794 <main+0xee>
 79c:	4401                	li	s0,0
{
	i2c_err_t i2c_ret = I2C_OK;

	// Wait for the bus to become not busy - return I2C_ERR_TIMEOUT on failure
	int32_t timeout = I2C_TIMEOUT;
	while(I2C1->STAR2 & I2C_STAR2_BUSY) 
 79e:	400054b7          	lui	s1,0x40005
 7a2:	0ff47513          	andi	a0,s0,255
	int32_t timeout = I2C_TIMEOUT;
 7a6:	7d000793          	li	a5,2000
	i2c_err_t i2c_ret = I2C_OK;
 7aa:	4701                	li	a4,0
 7ac:	a029                	j	7b6 <main+0x110>
		if(--timeout < 0) i2c_ret = I2C_ERR_BUSY;
 7ae:	17fd                	addi	a5,a5,-1
 7b0:	0007d363          	bgez	a5,7b6 <main+0x110>
 7b4:	4715                	li	a4,5
	while(I2C1->STAR2 & I2C_STAR2_BUSY) 
 7b6:	4184d603          	lhu	a2,1048(s1) # 40005418 <__global_pointer$+0x20004c18>
 7ba:	8a09                	andi	a2,a2,2
 7bc:	fa6d                	bnez	a2,7ae <main+0x108>

	if(i2c_ret == I2C_OK)
 7be:	e751                	bnez	a4,84a <main+0x1a4>
	{
		// Send a START Signal and wait for it to assert
		I2C1->CTLR1 |= I2C_CTLR1_START;
 7c0:	4004d783          	lhu	a5,1024(s1)
	return (status & status_mask) == status_mask; 
 7c4:	000306b7          	lui	a3,0x30
 7c8:	0685                	addi	a3,a3,1
		I2C1->CTLR1 |= I2C_CTLR1_START;
 7ca:	07c2                	slli	a5,a5,0x10
 7cc:	83c1                	srli	a5,a5,0x10
 7ce:	1007e793          	ori	a5,a5,256
 7d2:	40f49023          	sh	a5,1024(s1)
	uint32_t status = (uint32_t)I2C1->STAR1 | (uint32_t)(I2C1->STAR2 << 16);
 7d6:	4144d783          	lhu	a5,1044(s1)
 7da:	01079593          	slli	a1,a5,0x10
 7de:	4184d783          	lhu	a5,1048(s1)
 7e2:	81c1                	srli	a1,a1,0x10
 7e4:	07c2                	slli	a5,a5,0x10
 7e6:	8fcd                	or	a5,a5,a1
	return (status & status_mask) == status_mask; 
 7e8:	8ff5                	and	a5,a5,a3
		while(!i2c_status(I2C_EVENT_MASTER_MODE_SELECT));
 7ea:	fed796e3          	bne	a5,a3,7d6 <main+0x130>

		// Send the Address and wait for it to finish transmitting
		timeout = I2C_TIMEOUT;
		I2C1->DATAR = (addr << 1) & 0xFE;
 7ee:	00141793          	slli	a5,s0,0x1
 7f2:	07c2                	slli	a5,a5,0x10
 7f4:	83c1                	srli	a5,a5,0x10
	return (status & status_mask) == status_mask; 
 7f6:	00070637          	lui	a2,0x70
		I2C1->DATAR = (addr << 1) & 0xFE;
 7fa:	40f49823          	sh	a5,1040(s1)
 7fe:	7d100313          	li	t1,2001
	return (status & status_mask) == status_mask; 
 802:	08260613          	addi	a2,a2,130 # 70082 <lib_i2c.c.01c03b19+0x6c336>
	uint32_t status = (uint32_t)I2C1->STAR1 | (uint32_t)(I2C1->STAR2 << 16);
 806:	4144d683          	lhu	a3,1044(s1)
 80a:	40048793          	addi	a5,s1,1024
 80e:	01069593          	slli	a1,a3,0x10
 812:	0187d683          	lhu	a3,24(a5)
 816:	81c1                	srli	a1,a1,0x10
 818:	06c2                	slli	a3,a3,0x10
 81a:	8ecd                	or	a3,a3,a1
	return (status & status_mask) == status_mask; 
 81c:	8ef1                	and	a3,a3,a2
		// If the device times out, get the error status - if status is okay,
		// return generic I2C_ERR_BUSY Flag
		while(!i2c_status(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 81e:	02c68663          	beq	a3,a2,84a <main+0x1a4>
			if(--timeout < 0) {i2c_ret = i2c_get_busy_error(); break;}
 822:	137d                	addi	t1,t1,-1
 824:	fe0311e3          	bnez	t1,806 <main+0x160>
	if(I2C1->STAR1 & I2C_STAR1_BERR) {I2C1->STAR1 &= ~I2C_STAR1_BERR; return I2C_ERR_BERR;}
 828:	0147d703          	lhu	a4,20(a5)
 82c:	10077713          	andi	a4,a4,256
 830:	20070c63          	beqz	a4,a48 <main+0x3a2>
 834:	0147d703          	lhu	a4,20(a5)
 838:	0742                	slli	a4,a4,0x10
 83a:	8341                	srli	a4,a4,0x10
 83c:	eff77713          	andi	a4,a4,-257
 840:	0742                	slli	a4,a4,0x10
 842:	8341                	srli	a4,a4,0x10
 844:	00e79a23          	sh	a4,20(a5)
 848:	4705                	li	a4,1
	}

	// Send the STOP Signal, return i2c status
	I2C1->CTLR1 |= I2C_CTLR1_STOP;
 84a:	4004d783          	lhu	a5,1024(s1)
 84e:	07c2                	slli	a5,a5,0x10
 850:	83c1                	srli	a5,a5,0x10
 852:	2007e793          	ori	a5,a5,512
 856:	40f49023          	sh	a5,1024(s1)

	// Scan through every address, getting a ping() response
	for(uint8_t addr = 0x00; addr < 0x7F; addr++)
	{
		// If the address responds, call the callback function
		if(i2c_ping(addr) == I2C_OK) callback(addr);
 85a:	e311                	bnez	a4,85e <main+0x1b8>
 85c:	3581                	jal	69c <i2c_scan_callback>
 85e:	0405                	addi	s0,s0,1
	for(uint8_t addr = 0x00; addr < 0x7F; addr++)
 860:	07f00793          	li	a5,127
 864:	f2f41fe3          	bne	s0,a5,7a2 <main+0xfc>

static void InitTouchADC( );
void InitTouchADC( )
{
	// ADCCLK = 24 MHz => RCC_ADCPRE = 0: divide sys clock by 2
	RCC->CFGR0 &= ~(0x1F<<11);
 868:	400216b7          	lui	a3,0x40021
 86c:	42dc                	lw	a5,4(a3)
 86e:	7741                	lui	a4,0xffff0
 870:	7ff70713          	addi	a4,a4,2047 # ffff07ff <__global_pointer$+0xdffeffff>
 874:	8ff9                	and	a5,a5,a4
 876:	c2dc                	sw	a5,4(a3)

	// Set up single conversion on chl 2
	ADC1->RSQR1 = 0;
 878:	400127b7          	lui	a5,0x40012
 87c:	4207a623          	sw	zero,1068(a5) # 4001242c <__global_pointer$+0x20011c2c>
	ADC1->RSQR2 = 0;
 880:	4207a823          	sw	zero,1072(a5)

	// turn on ADC and set rule group to sw trig
	ADC1->CTLR2 |= ADC_ADON | ADC_EXTSEL;
 884:	4087a703          	lw	a4,1032(a5)
 888:	000e06b7          	lui	a3,0xe0
 88c:	0685                	addi	a3,a3,1
 88e:	8f55                	or	a4,a4,a3
 890:	40e7a423          	sw	a4,1032(a5)
	
	// Reset calibration
	ADC1->CTLR2 |= ADC_RSTCAL;
 894:	4087a703          	lw	a4,1032(a5)
	while(ADC1->CTLR2 & ADC_RSTCAL);
 898:	400126b7          	lui	a3,0x40012
	ADC1->CTLR2 |= ADC_RSTCAL;
 89c:	00876713          	ori	a4,a4,8
 8a0:	40e7a423          	sw	a4,1032(a5)
	while(ADC1->CTLR2 & ADC_RSTCAL);
 8a4:	4086a703          	lw	a4,1032(a3) # 40012408 <__global_pointer$+0x20011c08>
 8a8:	8b21                	andi	a4,a4,8
 8aa:	ff6d                	bnez	a4,8a4 <main+0x1fe>
	
	// Calibrate
	ADC1->CTLR2 |= ADC_CAL;
 8ac:	4086a703          	lw	a4,1032(a3)
 8b0:	00476713          	ori	a4,a4,4
 8b4:	40e6a423          	sw	a4,1032(a3)
	while(ADC1->CTLR2 & ADC_CAL);
 8b8:	40012737          	lui	a4,0x40012
 8bc:	40872783          	lw	a5,1032(a4) # 40012408 <__global_pointer$+0x20011c08>
 8c0:	8b91                	andi	a5,a5,4
 8c2:	ffed                	bnez	a5,8bc <main+0x216>
	InitTouchADC();
	//Wait until a capsense button is pressed, then dump 1kb of data from ntag to debug printf
	while(1) {
		uint32_t touchval = ReadTouchPin( GPIOD, 5, 5, 3);
		if(touchval > 50) {
			printf("Button pressed, reading ntag, writing then reading again\n");
 8c4:	6405                	lui	s0,0x1
		uint32_t touchval = ReadTouchPin( GPIOD, 5, 5, 3);
 8c6:	1ffff097          	auipc	ra,0x1ffff
 8ca:	73a080e7          	jalr	1850(ra) # 20000000 <ReadTouchPin.constprop.0>
		if(touchval > 50) {
 8ce:	03200793          	li	a5,50
 8d2:	fea7fae3          	bgeu	a5,a0,8c6 <main+0x220>
			printf("Button pressed, reading ntag, writing then reading again\n");
 8d6:	e9440513          	addi	a0,s0,-364 # e94 <handle_reset+0xb4>
 8da:	3b85                	jal	64a <puts>
			uint32_t block[4] = {0};
 8dc:	7d100693          	li	a3,2001
 8e0:	c202                	sw	zero,4(sp)
 8e2:	c402                	sw	zero,8(sp)
 8e4:	c602                	sw	zero,12(sp)
 8e6:	c802                	sw	zero,16(sp)
{
	i2c_err_t i2c_ret = I2C_OK;

	// Wait for the bus to become not busy - set state to I2C_ERR_TIMEOUT on failure
	int32_t timeout = I2C_TIMEOUT;
	while(I2C1->STAR2 & I2C_STAR2_BUSY) 
 8e8:	40005637          	lui	a2,0x40005
 8ec:	41865703          	lhu	a4,1048(a2) # 40005418 <__global_pointer$+0x20004c18>
 8f0:	40060793          	addi	a5,a2,1024
 8f4:	8b09                	andi	a4,a4,2
 8f6:	1a071e63          	bnez	a4,ab2 <main+0x40c>
		if(--timeout < 0) {i2c_ret = i2c_get_busy_error(); break;}
	
	if(i2c_ret == I2C_OK)
	{
		// Send a START Signal and wait for it to assert
		I2C1->CTLR1 |= I2C_CTLR1_START;
 8fa:	0007d703          	lhu	a4,0(a5)
	uint32_t status = (uint32_t)I2C1->STAR1 | (uint32_t)(I2C1->STAR2 << 16);
 8fe:	400055b7          	lui	a1,0x40005
		I2C1->CTLR1 |= I2C_CTLR1_START;
 902:	0742                	slli	a4,a4,0x10
 904:	8341                	srli	a4,a4,0x10
 906:	10076713          	ori	a4,a4,256
 90a:	00e79023          	sh	a4,0(a5)
	return (status & status_mask) == status_mask; 
 90e:	00030737          	lui	a4,0x30
 912:	0705                	addi	a4,a4,1
	uint32_t status = (uint32_t)I2C1->STAR1 | (uint32_t)(I2C1->STAR2 << 16);
 914:	4145d783          	lhu	a5,1044(a1) # 40005414 <__global_pointer$+0x20004c14>
 918:	01079613          	slli	a2,a5,0x10
 91c:	4185d783          	lhu	a5,1048(a1)
 920:	8241                	srli	a2,a2,0x10
 922:	07c2                	slli	a5,a5,0x10
 924:	8fd1                	or	a5,a5,a2
	return (status & status_mask) == status_mask; 
 926:	8ff9                	and	a5,a5,a4
		while(!i2c_status(I2C_EVENT_MASTER_MODE_SELECT));
 928:	fee796e3          	bne	a5,a4,914 <main+0x26e>

		// Send the Address and wait for it to finish transmitting
		timeout = I2C_TIMEOUT;
		I2C1->DATAR = (addr << 1) & 0xFE;
 92c:	4791                	li	a5,4
	return (status & status_mask) == status_mask; 
 92e:	000706b7          	lui	a3,0x70
		I2C1->DATAR = (addr << 1) & 0xFE;
 932:	40f59823          	sh	a5,1040(a1)
	uint32_t status = (uint32_t)I2C1->STAR1 | (uint32_t)(I2C1->STAR2 << 16);
 936:	40005537          	lui	a0,0x40005
		I2C1->DATAR = (addr << 1) & 0xFE;
 93a:	7d100593          	li	a1,2001
	return (status & status_mask) == status_mask; 
 93e:	08268693          	addi	a3,a3,130 # 70082 <lib_i2c.c.01c03b19+0x6c336>
	uint32_t status = (uint32_t)I2C1->STAR1 | (uint32_t)(I2C1->STAR2 << 16);
 942:	41455703          	lhu	a4,1044(a0) # 40005414 <__global_pointer$+0x20004c14>
 946:	40050793          	addi	a5,a0,1024
 94a:	01071613          	slli	a2,a4,0x10
 94e:	0187d703          	lhu	a4,24(a5)
 952:	8241                	srli	a2,a2,0x10
 954:	0742                	slli	a4,a4,0x10
 956:	8f51                	or	a4,a4,a2
	return (status & status_mask) == status_mask; 
 958:	8f75                	and	a4,a4,a3
		while(!i2c_status(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 95a:	2cd71163          	bne	a4,a3,c1c <main+0x576>
	}

	if(i2c_ret == I2C_OK)
	{
		// Send the Register Byte
		I2C1->DATAR = reg;
 95e:	03800713          	li	a4,56
 962:	00e79823          	sh	a4,16(a5)
		while(!(I2C1->STAR1 & I2C_STAR1_TXE));
 966:	400056b7          	lui	a3,0x40005
 96a:	4146d703          	lhu	a4,1044(a3) # 40005414 <__global_pointer$+0x20004c14>
 96e:	08077713          	andi	a4,a4,128
 972:	df65                	beqz	a4,96a <main+0x2c4>

		// If the message is long enough, enable ACK messages
		if(len > 1) I2C1->CTLR1 |= I2C_CTLR1_ACK;
 974:	4006d703          	lhu	a4,1024(a3)
	uint32_t status = (uint32_t)I2C1->STAR1 | (uint32_t)(I2C1->STAR2 << 16);
 978:	400055b7          	lui	a1,0x40005
		if(len > 1) I2C1->CTLR1 |= I2C_CTLR1_ACK;
 97c:	0742                	slli	a4,a4,0x10
 97e:	8341                	srli	a4,a4,0x10
 980:	40076713          	ori	a4,a4,1024
 984:	40e69023          	sh	a4,1024(a3)

		// Send a Repeated START Signal and wait for it to assert
		I2C1->CTLR1 |= I2C_CTLR1_START;
 988:	4006d703          	lhu	a4,1024(a3)
 98c:	0742                	slli	a4,a4,0x10
 98e:	8341                	srli	a4,a4,0x10
 990:	10076713          	ori	a4,a4,256
 994:	40e69023          	sh	a4,1024(a3)
	return (status & status_mask) == status_mask; 
 998:	00030737          	lui	a4,0x30
 99c:	0705                	addi	a4,a4,1
	uint32_t status = (uint32_t)I2C1->STAR1 | (uint32_t)(I2C1->STAR2 << 16);
 99e:	4145d783          	lhu	a5,1044(a1) # 40005414 <__global_pointer$+0x20004c14>
 9a2:	01079613          	slli	a2,a5,0x10
 9a6:	4185d783          	lhu	a5,1048(a1)
 9aa:	8241                	srli	a2,a2,0x10
 9ac:	07c2                	slli	a5,a5,0x10
 9ae:	8fd1                	or	a5,a5,a2
	return (status & status_mask) == status_mask; 
 9b0:	8ff9                	and	a5,a5,a4
		while(!i2c_status(I2C_EVENT_MASTER_MODE_SELECT));
 9b2:	fee796e3          	bne	a5,a4,99e <main+0x2f8>

		// Send Read Address
		timeout = I2C_TIMEOUT;
		I2C1->DATAR = (addr << 1) | 0x01;
 9b6:	4795                	li	a5,5
	return (status & status_mask) == status_mask; 
 9b8:	000306b7          	lui	a3,0x30
		I2C1->DATAR = (addr << 1) | 0x01;
 9bc:	40f59823          	sh	a5,1040(a1)
	uint32_t status = (uint32_t)I2C1->STAR1 | (uint32_t)(I2C1->STAR2 << 16);
 9c0:	40005537          	lui	a0,0x40005
		I2C1->DATAR = (addr << 1) | 0x01;
 9c4:	7d100593          	li	a1,2001
	return (status & status_mask) == status_mask; 
 9c8:	0689                	addi	a3,a3,2
	uint32_t status = (uint32_t)I2C1->STAR1 | (uint32_t)(I2C1->STAR2 << 16);
 9ca:	41455703          	lhu	a4,1044(a0) # 40005414 <__global_pointer$+0x20004c14>
 9ce:	40050793          	addi	a5,a0,1024
 9d2:	01071613          	slli	a2,a4,0x10
 9d6:	0187d703          	lhu	a4,24(a5)
 9da:	8241                	srli	a2,a2,0x10
 9dc:	0742                	slli	a4,a4,0x10
 9de:	8f51                	or	a4,a4,a2
	return (status & status_mask) == status_mask; 
 9e0:	8f75                	and	a4,a4,a3
		while(!i2c_status(I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
 9e2:	24d71163          	bne	a4,a3,c24 <main+0x57e>
	if(I2C1->STAR1 & I2C_STAR1_OVR) {I2C1->STAR1 &= ~I2C_STAR1_OVR; return I2C_ERR_OVR;}
 9e6:	6605                	lui	a2,0x1
		while(!i2c_status(I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
 9e8:	4681                	li	a3,0
		{
			// If this is the last byte, send the NACK Bit
			if(cbyte == len) I2C1->CTLR1 &= ~I2C_CTLR1_ACK;

			// Wait until the Read Register isn't empty
			while(!(I2C1->STAR1 & I2C_STAR1_RXNE));
 9ea:	40005537          	lui	a0,0x40005
	if(I2C1->STAR1 & I2C_STAR1_OVR) {I2C1->STAR1 &= ~I2C_STAR1_OVR; return I2C_ERR_OVR;}
 9ee:	80060613          	addi	a2,a2,-2048 # 800 <main+0x15a>
		while(cbyte < len)
 9f2:	45c1                	li	a1,16
			while(!(I2C1->STAR1 & I2C_STAR1_RXNE));
 9f4:	41455703          	lhu	a4,1044(a0) # 40005414 <__global_pointer$+0x20004c14>
 9f8:	40050793          	addi	a5,a0,1024
 9fc:	04077713          	andi	a4,a4,64
 a00:	db75                	beqz	a4,9f4 <main+0x34e>
			buf[cbyte] = I2C1->DATAR;
 a02:	0107d303          	lhu	t1,16(a5)
 a06:	0058                	addi	a4,sp,4
 a08:	9736                	add	a4,a4,a3
 a0a:	00670023          	sb	t1,0(a4) # 30000 <lib_i2c.c.01c03b19+0x2c2b4>
	if(I2C1->STAR1 & I2C_STAR1_BERR) {I2C1->STAR1 &= ~I2C_STAR1_BERR; return I2C_ERR_BERR;}
 a0e:	0147d703          	lhu	a4,20(a5)
 a12:	10077713          	andi	a4,a4,256
 a16:	e75d                	bnez	a4,ac4 <main+0x41e>
	if(I2C1->STAR1 & I2C_STAR1_AF) {I2C1->STAR1 &= ~I2C_STAR1_AF; return I2C_ERR_NACK;}
 a18:	0147d703          	lhu	a4,20(a5)
 a1c:	40077713          	andi	a4,a4,1024
 a20:	20071b63          	bnez	a4,c36 <main+0x590>
	if(I2C1->STAR1 & I2C_STAR1_ARLO) {I2C1->STAR1 &= ~I2C_STAR1_ARLO; return I2C_ERR_ARLO;}
 a24:	0147d703          	lhu	a4,20(a5)
 a28:	20077713          	andi	a4,a4,512
 a2c:	22071663          	bnez	a4,c58 <main+0x5b2>
	if(I2C1->STAR1 & I2C_STAR1_OVR) {I2C1->STAR1 &= ~I2C_STAR1_OVR; return I2C_ERR_OVR;}
 a30:	0147d703          	lhu	a4,20(a5)
 a34:	0742                	slli	a4,a4,0x10
 a36:	8341                	srli	a4,a4,0x10
 a38:	8f71                	and	a4,a4,a2
 a3a:	24071163          	bnez	a4,c7c <main+0x5d6>
 a3e:	0685                	addi	a3,a3,1
		while(cbyte < len)
 a40:	fab69ae3          	bne	a3,a1,9f4 <main+0x34e>
 a44:	4781                	li	a5,0
 a46:	a851                	j	ada <main+0x434>
	if(I2C1->STAR1 & I2C_STAR1_AF) {I2C1->STAR1 &= ~I2C_STAR1_AF; return I2C_ERR_NACK;}
 a48:	0147d703          	lhu	a4,20(a5)
 a4c:	40077713          	andi	a4,a4,1024
 a50:	cf09                	beqz	a4,a6a <main+0x3c4>
 a52:	0147d703          	lhu	a4,20(a5)
 a56:	0742                	slli	a4,a4,0x10
 a58:	8341                	srli	a4,a4,0x10
 a5a:	bff77713          	andi	a4,a4,-1025
 a5e:	0742                	slli	a4,a4,0x10
 a60:	8341                	srli	a4,a4,0x10
 a62:	00e79a23          	sh	a4,20(a5)
 a66:	4709                	li	a4,2
 a68:	b3cd                	j	84a <main+0x1a4>
	if(I2C1->STAR1 & I2C_STAR1_ARLO) {I2C1->STAR1 &= ~I2C_STAR1_ARLO; return I2C_ERR_ARLO;}
 a6a:	0147d703          	lhu	a4,20(a5)
 a6e:	20077713          	andi	a4,a4,512
 a72:	cf09                	beqz	a4,a8c <main+0x3e6>
 a74:	0147d703          	lhu	a4,20(a5)
 a78:	0742                	slli	a4,a4,0x10
 a7a:	8341                	srli	a4,a4,0x10
 a7c:	dff77713          	andi	a4,a4,-513
 a80:	0742                	slli	a4,a4,0x10
 a82:	8341                	srli	a4,a4,0x10
 a84:	00e79a23          	sh	a4,20(a5)
 a88:	470d                	li	a4,3
 a8a:	b3c1                	j	84a <main+0x1a4>
	if(I2C1->STAR1 & I2C_STAR1_OVR) {I2C1->STAR1 &= ~I2C_STAR1_OVR; return I2C_ERR_OVR;}
 a8c:	0147d683          	lhu	a3,20(a5)
	if(i2c_err == I2C_OK) i2c_err = I2C_ERR_BUSY;
 a90:	4715                	li	a4,5
	if(I2C1->STAR1 & I2C_STAR1_OVR) {I2C1->STAR1 &= ~I2C_STAR1_OVR; return I2C_ERR_OVR;}
 a92:	01469613          	slli	a2,a3,0x14
 a96:	da065ae3          	bgez	a2,84a <main+0x1a4>
 a9a:	0147d703          	lhu	a4,20(a5)
 a9e:	76fd                	lui	a3,0xfffff
 aa0:	7ff68693          	addi	a3,a3,2047 # fffff7ff <__global_pointer$+0xdfffefff>
 aa4:	0742                	slli	a4,a4,0x10
 aa6:	8341                	srli	a4,a4,0x10
 aa8:	8f75                	and	a4,a4,a3
 aaa:	00e79a23          	sh	a4,20(a5)
 aae:	4711                	li	a4,4
 ab0:	bb69                	j	84a <main+0x1a4>
 ab2:	16fd                	addi	a3,a3,-1
		if(--timeout < 0) {i2c_ret = i2c_get_busy_error(); break;}
 ab4:	e2069ce3          	bnez	a3,8ec <main+0x246>
	if(I2C1->STAR1 & I2C_STAR1_BERR) {I2C1->STAR1 &= ~I2C_STAR1_BERR; return I2C_ERR_BERR;}
 ab8:	0147d703          	lhu	a4,20(a5)
 abc:	10077713          	andi	a4,a4,256
 ac0:	16070663          	beqz	a4,c2c <main+0x586>
 ac4:	0147d703          	lhu	a4,20(a5)
 ac8:	0742                	slli	a4,a4,0x10
 aca:	8341                	srli	a4,a4,0x10
 acc:	eff77713          	andi	a4,a4,-257
 ad0:	0742                	slli	a4,a4,0x10
 ad2:	8341                	srli	a4,a4,0x10
 ad4:	00e79a23          	sh	a4,20(a5)
 ad8:	4785                	li	a5,1
			++cbyte;
		}
	}

	// Send the STOP Condition to auto-reset for the next operation
	I2C1->CTLR1 |= I2C_CTLR1_STOP;
 ada:	400056b7          	lui	a3,0x40005
 ade:	4006d703          	lhu	a4,1024(a3) # 40005400 <__global_pointer$+0x20004c00>
 ae2:	0742                	slli	a4,a4,0x10
 ae4:	8341                	srli	a4,a4,0x10
 ae6:	20076713          	ori	a4,a4,512
 aea:	40e69023          	sh	a4,1024(a3)
			i2c_err_t i2c_stat = i2c_read(NTAG_ADDR, 56, (uint8_t*) block, 16);
			if(i2c_stat != I2C_OK) printf("Error Using the I2C Bus\n");
 aee:	c789                	beqz	a5,af8 <main+0x452>
 af0:	6505                	lui	a0,0x1
 af2:	ed050513          	addi	a0,a0,-304 # ed0 <handle_reset+0xf0>
 af6:	3e91                	jal	64a <puts>
 af8:	005c                	addi	a5,sp,4
 afa:	84be                	mv	s1,a5
			for(int j=0; j<4; j++)
				printf("0x%lx, ", block[j]);
 afc:	6705                	lui	a4,0x1
 afe:	438c                	lw	a1,0(a5)
 b00:	ee870513          	addi	a0,a4,-280 # ee8 <handle_reset+0x108>
 b04:	c03e                	sw	a5,0(sp)
 b06:	3e85                	jal	676 <printf>
			for(int j=0; j<4; j++)
 b08:	4782                	lw	a5,0(sp)
 b0a:	0854                	addi	a3,sp,20
 b0c:	6705                	lui	a4,0x1
 b0e:	0791                	addi	a5,a5,4
 b10:	fef697e3          	bne	a3,a5,afe <main+0x458>
			
			block[2] = 0x0;
			block[3] = 0xff000000;
 b14:	ff0007b7          	lui	a5,0xff000
			block[2] = 0x0;
 b18:	c602                	sw	zero,12(sp)
			block[3] = 0xff000000;
 b1a:	c83e                	sw	a5,16(sp)
 b1c:	7d100693          	li	a3,2001
{
	i2c_err_t i2c_ret = I2C_OK;

	// Wait for the bus to become not busy - set state to I2C_ERR_TIMEOUT on failure
	int32_t timeout = I2C_TIMEOUT;
	while(I2C1->STAR2 & I2C_STAR2_BUSY) 
 b20:	40005637          	lui	a2,0x40005
 b24:	41865703          	lhu	a4,1048(a2) # 40005418 <__global_pointer$+0x20004c18>
 b28:	40060793          	addi	a5,a2,1024
 b2c:	8b09                	andi	a4,a4,2
 b2e:	16071563          	bnez	a4,c98 <main+0x5f2>
		if(--timeout < 0) {i2c_ret = i2c_get_busy_error(); break;}

	if(i2c_ret == I2C_OK)
	{
		// Send a START Signal and wait for it to assert
		I2C1->CTLR1 |= I2C_CTLR1_START;
 b32:	0007d703          	lhu	a4,0(a5) # ff000000 <__global_pointer$+0xdefff800>
	uint32_t status = (uint32_t)I2C1->STAR1 | (uint32_t)(I2C1->STAR2 << 16);
 b36:	400055b7          	lui	a1,0x40005
		I2C1->CTLR1 |= I2C_CTLR1_START;
 b3a:	0742                	slli	a4,a4,0x10
 b3c:	8341                	srli	a4,a4,0x10
 b3e:	10076713          	ori	a4,a4,256
 b42:	00e79023          	sh	a4,0(a5)
	return (status & status_mask) == status_mask; 
 b46:	00030737          	lui	a4,0x30
 b4a:	0705                	addi	a4,a4,1
	uint32_t status = (uint32_t)I2C1->STAR1 | (uint32_t)(I2C1->STAR2 << 16);
 b4c:	4145d783          	lhu	a5,1044(a1) # 40005414 <__global_pointer$+0x20004c14>
 b50:	01079613          	slli	a2,a5,0x10
 b54:	4185d783          	lhu	a5,1048(a1)
 b58:	8241                	srli	a2,a2,0x10
 b5a:	07c2                	slli	a5,a5,0x10
 b5c:	8fd1                	or	a5,a5,a2
	return (status & status_mask) == status_mask; 
 b5e:	8ff9                	and	a5,a5,a4
		while(!i2c_status(I2C_EVENT_MASTER_MODE_SELECT));
 b60:	fee796e3          	bne	a5,a4,b4c <main+0x4a6>

		// Send the Address and wait for it to finish transmitting
		timeout = I2C_TIMEOUT;
		I2C1->DATAR = (addr << 1) & 0xFE;
 b64:	4791                	li	a5,4
	return (status & status_mask) == status_mask; 
 b66:	000706b7          	lui	a3,0x70
		I2C1->DATAR = (addr << 1) & 0xFE;
 b6a:	40f59823          	sh	a5,1040(a1)
	uint32_t status = (uint32_t)I2C1->STAR1 | (uint32_t)(I2C1->STAR2 << 16);
 b6e:	40005537          	lui	a0,0x40005
		I2C1->DATAR = (addr << 1) & 0xFE;
 b72:	7d100593          	li	a1,2001
	return (status & status_mask) == status_mask; 
 b76:	08268693          	addi	a3,a3,130 # 70082 <lib_i2c.c.01c03b19+0x6c336>
	uint32_t status = (uint32_t)I2C1->STAR1 | (uint32_t)(I2C1->STAR2 << 16);
 b7a:	41455703          	lhu	a4,1044(a0) # 40005414 <__global_pointer$+0x20004c14>
 b7e:	40050793          	addi	a5,a0,1024
 b82:	01071613          	slli	a2,a4,0x10
 b86:	0187d703          	lhu	a4,24(a5)
 b8a:	8241                	srli	a2,a2,0x10
 b8c:	0742                	slli	a4,a4,0x10
 b8e:	8f51                	or	a4,a4,a2
	return (status & status_mask) == status_mask; 
 b90:	8f75                	and	a4,a4,a3
		while(!i2c_status(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
 b92:	16d71463          	bne	a4,a3,cfa <main+0x654>


	if(i2c_ret == I2C_OK)
	{
		// Send the Register Byte
		I2C1->DATAR = reg;
 b96:	03800713          	li	a4,56
 b9a:	00e79823          	sh	a4,16(a5)
		while(!(I2C1->STAR1 & I2C_STAR1_TXE));
 b9e:	40005737          	lui	a4,0x40005
 ba2:	41475783          	lhu	a5,1044(a4) # 40005414 <__global_pointer$+0x20004c14>
 ba6:	0807f793          	andi	a5,a5,128
 baa:	dfe5                	beqz	a5,ba2 <main+0x4fc>
	if(I2C1->STAR1 & I2C_STAR1_OVR) {I2C1->STAR1 &= ~I2C_STAR1_OVR; return I2C_ERR_OVR;}
 bac:	6605                	lui	a2,0x1
		while(!(I2C1->STAR1 & I2C_STAR1_TXE));
 bae:	4681                	li	a3,0
		// Write bytes
		uint8_t cbyte = 0;
		while(cbyte < len)
		{
			// Write the byte and wait for it to finish transmitting
			while(!(I2C1->STAR1 & I2C_STAR1_TXE));
 bb0:	40005537          	lui	a0,0x40005
	if(I2C1->STAR1 & I2C_STAR1_OVR) {I2C1->STAR1 &= ~I2C_STAR1_OVR; return I2C_ERR_OVR;}
 bb4:	80060613          	addi	a2,a2,-2048 # 800 <main+0x15a>
		while(cbyte < len)
 bb8:	45c1                	li	a1,16
			while(!(I2C1->STAR1 & I2C_STAR1_TXE));
 bba:	41455703          	lhu	a4,1044(a0) # 40005414 <__global_pointer$+0x20004c14>
 bbe:	40050793          	addi	a5,a0,1024
 bc2:	08077713          	andi	a4,a4,128
 bc6:	db75                	beqz	a4,bba <main+0x514>
			I2C1->DATAR = buf[cbyte];
 bc8:	00d48733          	add	a4,s1,a3
 bcc:	00074703          	lbu	a4,0(a4)
 bd0:	00e79823          	sh	a4,16(a5)
	if(I2C1->STAR1 & I2C_STAR1_BERR) {I2C1->STAR1 &= ~I2C_STAR1_BERR; return I2C_ERR_BERR;}
 bd4:	0147d703          	lhu	a4,20(a5)
 bd8:	10077713          	andi	a4,a4,256
 bdc:	18070763          	beqz	a4,d6a <main+0x6c4>
 be0:	0147d703          	lhu	a4,20(a5)
 be4:	0742                	slli	a4,a4,0x10
 be6:	8341                	srli	a4,a4,0x10
 be8:	eff77713          	andi	a4,a4,-257
 bec:	0742                	slli	a4,a4,0x10
 bee:	8341                	srli	a4,a4,0x10
 bf0:	00e79a23          	sh	a4,20(a5)
 bf4:	4785                	li	a5,1
	return (status & status_mask) == status_mask; 
 bf6:	000706b7          	lui	a3,0x70
	uint32_t status = (uint32_t)I2C1->STAR1 | (uint32_t)(I2C1->STAR2 << 16);
 bfa:	40005537          	lui	a0,0x40005
	return (status & status_mask) == status_mask; 
 bfe:	08468693          	addi	a3,a3,132 # 70084 <lib_i2c.c.01c03b19+0x6c338>
	uint32_t status = (uint32_t)I2C1->STAR1 | (uint32_t)(I2C1->STAR2 << 16);
 c02:	41455703          	lhu	a4,1044(a0) # 40005414 <__global_pointer$+0x20004c14>
 c06:	01071613          	slli	a2,a4,0x10
 c0a:	41855703          	lhu	a4,1048(a0)
 c0e:	8241                	srli	a2,a2,0x10
 c10:	0742                	slli	a4,a4,0x10
 c12:	8f51                	or	a4,a4,a2
	return (status & status_mask) == status_mask; 
 c14:	8f75                	and	a4,a4,a3

			++cbyte;
		}

		// Wait for the bus to finish transmitting
		while(!i2c_status(I2C_EVENT_MASTER_BYTE_TRANSMITTED));
 c16:	fed716e3          	bne	a4,a3,c02 <main+0x55c>
 c1a:	a055                	j	cbe <main+0x618>
 c1c:	15fd                	addi	a1,a1,-1
			if(--timeout < 0) {i2c_ret = i2c_get_busy_error(); break;}
 c1e:	d20592e3          	bnez	a1,942 <main+0x29c>
 c22:	bd59                	j	ab8 <main+0x412>
 c24:	15fd                	addi	a1,a1,-1
			if(--timeout < 0) {i2c_ret = i2c_get_busy_error(); break;}
 c26:	da0592e3          	bnez	a1,9ca <main+0x324>
 c2a:	b579                	j	ab8 <main+0x412>
	if(I2C1->STAR1 & I2C_STAR1_AF) {I2C1->STAR1 &= ~I2C_STAR1_AF; return I2C_ERR_NACK;}
 c2c:	0147d703          	lhu	a4,20(a5)
 c30:	40077713          	andi	a4,a4,1024
 c34:	cf09                	beqz	a4,c4e <main+0x5a8>
 c36:	0147d703          	lhu	a4,20(a5)
 c3a:	0742                	slli	a4,a4,0x10
 c3c:	8341                	srli	a4,a4,0x10
 c3e:	bff77713          	andi	a4,a4,-1025
 c42:	0742                	slli	a4,a4,0x10
 c44:	8341                	srli	a4,a4,0x10
 c46:	00e79a23          	sh	a4,20(a5)
 c4a:	4789                	li	a5,2
 c4c:	b579                	j	ada <main+0x434>
	if(I2C1->STAR1 & I2C_STAR1_ARLO) {I2C1->STAR1 &= ~I2C_STAR1_ARLO; return I2C_ERR_ARLO;}
 c4e:	0147d703          	lhu	a4,20(a5)
 c52:	20077713          	andi	a4,a4,512
 c56:	cf09                	beqz	a4,c70 <main+0x5ca>
 c58:	0147d703          	lhu	a4,20(a5)
 c5c:	0742                	slli	a4,a4,0x10
 c5e:	8341                	srli	a4,a4,0x10
 c60:	dff77713          	andi	a4,a4,-513
 c64:	0742                	slli	a4,a4,0x10
 c66:	8341                	srli	a4,a4,0x10
 c68:	00e79a23          	sh	a4,20(a5)
 c6c:	478d                	li	a5,3
 c6e:	b5b5                	j	ada <main+0x434>
	if(I2C1->STAR1 & I2C_STAR1_OVR) {I2C1->STAR1 &= ~I2C_STAR1_OVR; return I2C_ERR_OVR;}
 c70:	0147d703          	lhu	a4,20(a5)
 c74:	01471693          	slli	a3,a4,0x14
 c78:	0006de63          	bgez	a3,c94 <main+0x5ee>
 c7c:	0147d703          	lhu	a4,20(a5)
 c80:	76fd                	lui	a3,0xfffff
 c82:	7ff68693          	addi	a3,a3,2047 # fffff7ff <__global_pointer$+0xdfffefff>
 c86:	0742                	slli	a4,a4,0x10
 c88:	8341                	srli	a4,a4,0x10
 c8a:	8f75                	and	a4,a4,a3
 c8c:	00e79a23          	sh	a4,20(a5)
 c90:	4791                	li	a5,4
 c92:	b5a1                	j	ada <main+0x434>
	if(i2c_err == I2C_OK) i2c_err = I2C_ERR_BUSY;
 c94:	4795                	li	a5,5
 c96:	b591                	j	ada <main+0x434>
 c98:	16fd                	addi	a3,a3,-1
		if(--timeout < 0) {i2c_ret = i2c_get_busy_error(); break;}
 c9a:	e80695e3          	bnez	a3,b24 <main+0x47e>
	if(I2C1->STAR1 & I2C_STAR1_BERR) {I2C1->STAR1 &= ~I2C_STAR1_BERR; return I2C_ERR_BERR;}
 c9e:	0147d703          	lhu	a4,20(a5)
 ca2:	10077713          	andi	a4,a4,256
 ca6:	cf31                	beqz	a4,d02 <main+0x65c>
 ca8:	0147d703          	lhu	a4,20(a5)
 cac:	0742                	slli	a4,a4,0x10
 cae:	8341                	srli	a4,a4,0x10
 cb0:	eff77713          	andi	a4,a4,-257
 cb4:	0742                	slli	a4,a4,0x10
 cb6:	8341                	srli	a4,a4,0x10
 cb8:	00e79a23          	sh	a4,20(a5)
 cbc:	4785                	li	a5,1
	}

	// Send a STOP Condition, to aut-reset for the next operation
	I2C1->CTLR1 |= I2C_CTLR1_STOP;
 cbe:	400056b7          	lui	a3,0x40005
 cc2:	4006d703          	lhu	a4,1024(a3) # 40005400 <__global_pointer$+0x20004c00>
 cc6:	0742                	slli	a4,a4,0x10
 cc8:	8341                	srli	a4,a4,0x10
 cca:	20076713          	ori	a4,a4,512
 cce:	40e69023          	sh	a4,1024(a3)
			i2c_stat = i2c_write(NTAG_ADDR, 56, (uint8_t*) block, 16);
			if(i2c_stat != I2C_OK) 
 cd2:	c789                	beqz	a5,cdc <main+0x636>
				printf("Error Using the I2C Bus\n");
 cd4:	6505                	lui	a0,0x1
 cd6:	ed050513          	addi	a0,a0,-304 # ed0 <handle_reset+0xf0>
 cda:	3a85                	jal	64a <puts>
	uint32_t targend = SysTick->CNT + n;
 cdc:	e000f7b7          	lui	a5,0xe000f
 ce0:	4798                	lw	a4,8(a5)
 ce2:	0003b7b7          	lui	a5,0x3b
 ce6:	98078793          	addi	a5,a5,-1664 # 3a980 <lib_i2c.c.01c03b19+0x36c34>
 cea:	973e                	add	a4,a4,a5
	while( ((int32_t)( SysTick->CNT - targend )) < 0 );
 cec:	e000f6b7          	lui	a3,0xe000f
 cf0:	469c                	lw	a5,8(a3)
 cf2:	8f99                	sub	a5,a5,a4
 cf4:	fe07cee3          	bltz	a5,cf0 <main+0x64a>
 cf8:	b6f9                	j	8c6 <main+0x220>
 cfa:	15fd                	addi	a1,a1,-1
			if(--timeout < 0) {i2c_ret = i2c_get_busy_error(); break;}
 cfc:	e6059fe3          	bnez	a1,b7a <main+0x4d4>
 d00:	bf79                	j	c9e <main+0x5f8>
	if(I2C1->STAR1 & I2C_STAR1_AF) {I2C1->STAR1 &= ~I2C_STAR1_AF; return I2C_ERR_NACK;}
 d02:	0147d703          	lhu	a4,20(a5)
 d06:	40077713          	andi	a4,a4,1024
 d0a:	cf09                	beqz	a4,d24 <main+0x67e>
 d0c:	0147d703          	lhu	a4,20(a5)
 d10:	0742                	slli	a4,a4,0x10
 d12:	8341                	srli	a4,a4,0x10
 d14:	bff77713          	andi	a4,a4,-1025
 d18:	0742                	slli	a4,a4,0x10
 d1a:	8341                	srli	a4,a4,0x10
 d1c:	00e79a23          	sh	a4,20(a5)
 d20:	4789                	li	a5,2
 d22:	bf71                	j	cbe <main+0x618>
	if(I2C1->STAR1 & I2C_STAR1_ARLO) {I2C1->STAR1 &= ~I2C_STAR1_ARLO; return I2C_ERR_ARLO;}
 d24:	0147d703          	lhu	a4,20(a5)
 d28:	20077713          	andi	a4,a4,512
 d2c:	cf09                	beqz	a4,d46 <main+0x6a0>
 d2e:	0147d703          	lhu	a4,20(a5)
 d32:	0742                	slli	a4,a4,0x10
 d34:	8341                	srli	a4,a4,0x10
 d36:	dff77713          	andi	a4,a4,-513
 d3a:	0742                	slli	a4,a4,0x10
 d3c:	8341                	srli	a4,a4,0x10
 d3e:	00e79a23          	sh	a4,20(a5)
 d42:	478d                	li	a5,3
 d44:	bfad                	j	cbe <main+0x618>
	if(I2C1->STAR1 & I2C_STAR1_OVR) {I2C1->STAR1 &= ~I2C_STAR1_OVR; return I2C_ERR_OVR;}
 d46:	0147d703          	lhu	a4,20(a5)
 d4a:	01471693          	slli	a3,a4,0x14
 d4e:	0806d763          	bgez	a3,ddc <main+0x736>
 d52:	0147d703          	lhu	a4,20(a5)
 d56:	76fd                	lui	a3,0xfffff
 d58:	7ff68693          	addi	a3,a3,2047 # fffff7ff <__global_pointer$+0xdfffefff>
 d5c:	0742                	slli	a4,a4,0x10
 d5e:	8341                	srli	a4,a4,0x10
 d60:	8f75                	and	a4,a4,a3
 d62:	00e79a23          	sh	a4,20(a5)
 d66:	4791                	li	a5,4
 d68:	bf99                	j	cbe <main+0x618>
	if(I2C1->STAR1 & I2C_STAR1_AF) {I2C1->STAR1 &= ~I2C_STAR1_AF; return I2C_ERR_NACK;}
 d6a:	0147d703          	lhu	a4,20(a5)
 d6e:	40077713          	andi	a4,a4,1024
 d72:	cf09                	beqz	a4,d8c <main+0x6e6>
 d74:	0147d703          	lhu	a4,20(a5)
 d78:	0742                	slli	a4,a4,0x10
 d7a:	8341                	srli	a4,a4,0x10
 d7c:	bff77713          	andi	a4,a4,-1025
 d80:	0742                	slli	a4,a4,0x10
 d82:	8341                	srli	a4,a4,0x10
 d84:	00e79a23          	sh	a4,20(a5)
 d88:	4789                	li	a5,2
 d8a:	b5b5                	j	bf6 <main+0x550>
	if(I2C1->STAR1 & I2C_STAR1_ARLO) {I2C1->STAR1 &= ~I2C_STAR1_ARLO; return I2C_ERR_ARLO;}
 d8c:	0147d703          	lhu	a4,20(a5)
 d90:	20077713          	andi	a4,a4,512
 d94:	cf09                	beqz	a4,dae <main+0x708>
 d96:	0147d703          	lhu	a4,20(a5)
 d9a:	0742                	slli	a4,a4,0x10
 d9c:	8341                	srli	a4,a4,0x10
 d9e:	dff77713          	andi	a4,a4,-513
 da2:	0742                	slli	a4,a4,0x10
 da4:	8341                	srli	a4,a4,0x10
 da6:	00e79a23          	sh	a4,20(a5)
 daa:	478d                	li	a5,3
 dac:	b5a9                	j	bf6 <main+0x550>
	if(I2C1->STAR1 & I2C_STAR1_OVR) {I2C1->STAR1 &= ~I2C_STAR1_OVR; return I2C_ERR_OVR;}
 dae:	0147d703          	lhu	a4,20(a5)
 db2:	0742                	slli	a4,a4,0x10
 db4:	8341                	srli	a4,a4,0x10
 db6:	8f71                	and	a4,a4,a2
 db8:	cf09                	beqz	a4,dd2 <main+0x72c>
 dba:	0147d703          	lhu	a4,20(a5)
 dbe:	76fd                	lui	a3,0xfffff
 dc0:	7ff68693          	addi	a3,a3,2047 # fffff7ff <__global_pointer$+0xdfffefff>
 dc4:	0742                	slli	a4,a4,0x10
 dc6:	8341                	srli	a4,a4,0x10
 dc8:	8f75                	and	a4,a4,a3
 dca:	00e79a23          	sh	a4,20(a5)
 dce:	4791                	li	a5,4
 dd0:	b51d                	j	bf6 <main+0x550>
 dd2:	0685                	addi	a3,a3,1
		while(cbyte < len)
 dd4:	deb693e3          	bne	a3,a1,bba <main+0x514>
 dd8:	4781                	li	a5,0
 dda:	bd31                	j	bf6 <main+0x550>
	if(i2c_err == I2C_OK) i2c_err = I2C_ERR_BUSY;
 ddc:	4795                	li	a5,5
 dde:	b5c5                	j	cbe <main+0x618>

00000de0 <handle_reset>:
	asm volatile( "\n\
 de0:	20000197          	auipc	gp,0x20000
 de4:	a2018193          	addi	gp,gp,-1504 # 20000800 <__global_pointer$>
 de8:	00018113          	mv	sp,gp
 dec:	08000513          	li	a0,128
 df0:	30051073          	csrw	mstatus,a0
 df4:	468d                	li	a3,3
 df6:	fffff517          	auipc	a0,0xfffff
 dfa:	20a50513          	addi	a0,a0,522 # 0 <InterruptVector>
 dfe:	8d55                	or	a0,a0,a3
 e00:	30551073          	csrw	mtvec,a0
asm volatile(
 e04:	9e818513          	addi	a0,gp,-1560 # 200001e8 <_ebss>
 e08:	9e818593          	addi	a1,gp,-1560 # 200001e8 <_ebss>
 e0c:	4601                	li	a2,0
 e0e:	00b55663          	bge	a0,a1,e1a <handle_reset+0x3a>
 e12:	c110                	sw	a2,0(a0)
 e14:	0511                	addi	a0,a0,4
 e16:	feb54ee3          	blt	a0,a1,e12 <handle_reset+0x32>
 e1a:	00000517          	auipc	a0,0x0
 e1e:	0d650513          	addi	a0,a0,214 # ef0 <_data_lma>
 e22:	1ffff597          	auipc	a1,0x1ffff
 e26:	1de58593          	addi	a1,a1,478 # 20000000 <ReadTouchPin.constprop.0>
 e2a:	1ffff617          	auipc	a2,0x1ffff
 e2e:	3be60613          	addi	a2,a2,958 # 200001e8 <_ebss>
 e32:	00c58863          	beq	a1,a2,e42 <handle_reset+0x62>
 e36:	4114                	lw	a3,0(a0)
 e38:	c194                	sw	a3,0(a1)
 e3a:	0511                	addi	a0,a0,4
 e3c:	0591                	addi	a1,a1,4
 e3e:	fec59ae3          	bne	a1,a2,e32 <handle_reset+0x52>
	SysTick->CTLR = 5;
 e42:	e000f7b7          	lui	a5,0xe000f
 e46:	4715                	li	a4,5
 e48:	c398                	sw	a4,0(a5)
asm volatile(
 e4a:	6a600793          	li	a5,1702
 e4e:	34179073          	csrw	mepc,a5
 e52:	30200073          	mret
 e56:	0000                	unimp
 e58:	000a                	c.slli	zero,0x2
 e5a:	0000                	unimp
 e5c:	6441                	lui	s0,0x10
 e5e:	7264                	flw	fs1,100(a2)
 e60:	7365                	lui	t1,0xffff9
 e62:	30203a73          	csrrc	s4,medeleg,zero
 e66:	2578                	fld	fa4,200(a0)
 e68:	3230                	fld	fa2,96(a2)
 e6a:	2058                	fld	fa4,128(s0)
 e6c:	6552                	flw	fa0,20(sp)
 e6e:	6e6f7073          	csrci	0x6e6,30
 e72:	6564                	flw	fs1,76(a0)
 e74:	2e64                	fld	fs1,216(a2)
 e76:	000a                	c.slli	zero,0x2
 e78:	6146                	flw	ft2,80(sp)
 e7a:	6c69                	lui	s8,0x1a
 e7c:	6465                	lui	s0,0x19
 e7e:	7420                	flw	fs0,104(s0)
 e80:	6e69206f          	j	93566 <lib_i2c.c.01c03b19+0x8f81a>
 e84:	7469                	lui	s0,0xffffa
 e86:	7420                	flw	fs0,104(s0)
 e88:	6568                	flw	fa0,76(a0)
 e8a:	4920                	lw	s0,80(a0)
 e8c:	4332                	lw	t1,12(sp)
 e8e:	4220                	lw	s0,64(a2)
 e90:	7375                	lui	t1,0xffffd
 e92:	0000                	unimp
 e94:	7542                	flw	fa0,48(sp)
 e96:	7474                	flw	fa3,108(s0)
 e98:	70206e6f          	jal	t3,759a <lib_i2c.c.01c03b19+0x384e>
 e9c:	6572                	flw	fa0,28(sp)
 e9e:	64657373          	csrrci	t1,0x646,10
 ea2:	202c                	fld	fa1,64(s0)
 ea4:	6572                	flw	fa0,28(sp)
 ea6:	6461                	lui	s0,0x18
 ea8:	6e69                	lui	t3,0x1a
 eaa:	746e2067          	0x746e2067
 eae:	6761                	lui	a4,0x18
 eb0:	202c                	fld	fa1,64(s0)
 eb2:	74697277          	0x74697277
 eb6:	6e69                	lui	t3,0x1a
 eb8:	68742067          	0x68742067
 ebc:	6e65                	lui	t3,0x19
 ebe:	7220                	flw	fs0,96(a2)
 ec0:	6165                	addi	sp,sp,112
 ec2:	6964                	flw	fs1,84(a0)
 ec4:	676e                	flw	fa4,216(sp)
 ec6:	6120                	flw	fs0,64(a0)
 ec8:	6e696167          	0x6e696167
 ecc:	0000                	unimp
 ece:	0000                	unimp
 ed0:	7245                	lui	tp,0xffff1
 ed2:	6f72                	flw	ft10,28(sp)
 ed4:	2072                	fld	ft0,280(sp)
 ed6:	7355                	lui	t1,0xffff5
 ed8:	6e69                	lui	t3,0x1a
 eda:	68742067          	0x68742067
 ede:	2065                	jal	f86 <_data_lma+0x96>
 ee0:	3249                	jal	862 <main+0x1bc>
 ee2:	75422043          	0x75422043
 ee6:	78300073          	0x78300073
 eea:	6c25                	lui	s8,0x9
 eec:	2c78                	fld	fa4,216(s0)
 eee:	0020                	addi	s0,sp,8

Disassembly of section .data:

20000000 <ReadTouchPin.constprop.0>:
}

// Run from RAM to get even more stable timing.
// This function call takes about 8.1uS to execute.
static uint32_t ReadTouchPin( GPIO_TypeDef * io, int portpin, int adcno, int iterations ) __attribute__((noinline, section(".srodata")));
uint32_t ReadTouchPin( GPIO_TypeDef * io, int portpin, int adcno, int iterations )
20000000:	1111                	addi	sp,sp,-28
20000002:	cc06                	sw	ra,24(sp)
20000004:	ca22                	sw	s0,20(sp)
20000006:	c826                	sw	s1,16(sp)
{
	uint32_t ret = 0;

	__disable_irq();
20000008:	210000e7          	jalr	528(zero) # 0 <InterruptVector>
	FORCEALIGNADC
2000000c:	e000f7b7          	lui	a5,0xe000f
20000010:	479c                	lw	a5,8(a5)
20000012:	0001                	nop
20000014:	0037f613          	andi	a2,a5,3
20000018:	0606                	slli	a2,a2,0x1
2000001a:	0631                	addi	a2,a2,12
2000001c:	00000597          	auipc	a1,0x0
20000020:	962e                	add	a2,a2,a1
20000022:	001600e7          	jalr	1(a2)
20000026:	0001                	nop
20000028:	0001                	nop
2000002a:	0001                	nop
2000002c:	0001                	nop
	ADC1->RSQR3 = adcno;
2000002e:	400127b7          	lui	a5,0x40012
20000032:	4715                	li	a4,5
20000034:	42e7aa23          	sw	a4,1076(a5) # 40012434 <__global_pointer$+0x20011c34>
	ADC1->SAMPTR2 = TOUCH_ADC_SAMPLE_TIME<<(3*adcno);
20000038:	6741                	lui	a4,0x10
2000003a:	40e7a823          	sw	a4,1040(a5)
	__enable_irq();
2000003e:	21e000e7          	jalr	542(zero) # 0 <InterruptVector>

	uint32_t CFGBASE = io->CFGLR & (~(0xf<<(4*portpin)));
20000042:	400117b7          	lui	a5,0x40011
20000046:	4007a783          	lw	a5,1024(a5) # 40011400 <__global_pointer$+0x20010c00>
2000004a:	ff100737          	lui	a4,0xff100
2000004e:	177d                	addi	a4,a4,-1
20000050:	8ff9                	and	a5,a5,a4
	uint32_t CFGFLOAT = ((GPIO_CFGLR_IN_PUPD)<<(4*portpin)) | CFGBASE;
20000052:	00800437          	lui	s0,0x800
	uint32_t CFGDRIVE = (GPIO_CFGLR_OUT_2Mhz_PP)<<(4*portpin) | CFGBASE;
20000056:	00200737          	lui	a4,0x200
	uint32_t CFGFLOAT = ((GPIO_CFGLR_IN_PUPD)<<(4*portpin)) | CFGBASE;
2000005a:	8c5d                	or	s0,s0,a5
	uint32_t CFGDRIVE = (GPIO_CFGLR_OUT_2Mhz_PP)<<(4*portpin) | CFGBASE;
2000005c:	8fd9                	or	a5,a5,a4
2000005e:	c03e                	sw	a5,0(sp)
	for( i = 0; i < iterations; i++ )
	{
		// Wait a variable amount of time based on loop iteration, in order
		// to get a variety of RC points and minimize DNL.

		INNER_LOOP( 0 );
20000060:	004e04b7          	lui	s1,0x4e0
	uint32_t CFGDRIVE = (GPIO_CFGLR_OUT_2Mhz_PP)<<(4*portpin) | CFGBASE;
20000064:	478d                	li	a5,3
20000066:	c23e                	sw	a5,4(sp)
	uint32_t ret = 0;
20000068:	4501                	li	a0,0
		INNER_LOOP( 0 );
2000006a:	0485                	addi	s1,s1,1
2000006c:	c42a                	sw	a0,8(sp)
2000006e:	210000e7          	jalr	528(zero) # 0 <InterruptVector>
20000072:	e000f7b7          	lui	a5,0xe000f
20000076:	479c                	lw	a5,8(a5)
20000078:	0037f613          	andi	a2,a5,3
2000007c:	0606                	slli	a2,a2,0x1
2000007e:	0631                	addi	a2,a2,12
20000080:	00000597          	auipc	a1,0x0
20000084:	962e                	add	a2,a2,a1
20000086:	001600e7          	jalr	1(a2)
2000008a:	0001                	nop
2000008c:	0001                	nop
2000008e:	0001                	nop
20000090:	0001                	nop
20000092:	400127b7          	lui	a5,0x40012
20000096:	4097a423          	sw	s1,1032(a5) # 40012408 <__global_pointer$+0x20011c08>
2000009a:	400117b7          	lui	a5,0x40011
2000009e:	40078713          	addi	a4,a5,1024 # 40011400 <__global_pointer$+0x20010c00>
200000a2:	4087a023          	sw	s0,1024(a5)
200000a6:	002007b7          	lui	a5,0x200
200000aa:	cb1c                	sw	a5,16(a4)
200000ac:	21e000e7          	jalr	542(zero) # 0 <InterruptVector>
200000b0:	4522                	lw	a0,8(sp)
200000b2:	40012737          	lui	a4,0x40012
200000b6:	40072783          	lw	a5,1024(a4) # 40012400 <__global_pointer$+0x20011c00>
200000ba:	40070313          	addi	t1,a4,1024
200000be:	8b89                	andi	a5,a5,2
200000c0:	dbfd                	beqz	a5,200000b6 <ReadTouchPin.constprop.0+0xb6>
200000c2:	4782                	lw	a5,0(sp)
200000c4:	c62a                	sw	a0,12(sp)
200000c6:	40011737          	lui	a4,0x40011
200000ca:	40f72023          	sw	a5,1024(a4) # 40011400 <__global_pointer$+0x20010c00>
200000ce:	02000793          	li	a5,32
200000d2:	40f72823          	sw	a5,1040(a4)
200000d6:	04c32783          	lw	a5,76(t1) # ffff504c <__global_pointer$+0xdfff484c>
200000da:	c43e                	sw	a5,8(sp)
		INNER_LOOP( 2 );
200000dc:	210000e7          	jalr	528(zero) # 0 <InterruptVector>
200000e0:	e000f637          	lui	a2,0xe000f
200000e4:	00862283          	lw	t0,8(a2) # e000f008 <__global_pointer$+0xc000e808>
200000e8:	0032f613          	andi	a2,t0,3
200000ec:	0606                	slli	a2,a2,0x1
200000ee:	0631                	addi	a2,a2,12
200000f0:	00000597          	auipc	a1,0x0
200000f4:	962e                	add	a2,a2,a1
200000f6:	001600e7          	jalr	1(a2)
200000fa:	0001                	nop
200000fc:	0001                	nop
200000fe:	0001                	nop
20000100:	0001                	nop
20000102:	400127b7          	lui	a5,0x40012
20000106:	4097a423          	sw	s1,1032(a5) # 40012408 <__global_pointer$+0x20011c08>
2000010a:	0001                	nop
2000010c:	0001                	nop
2000010e:	40011737          	lui	a4,0x40011
20000112:	40872023          	sw	s0,1024(a4) # 40011400 <__global_pointer$+0x20010c00>
20000116:	400117b7          	lui	a5,0x40011
2000011a:	00200737          	lui	a4,0x200
2000011e:	40e7a823          	sw	a4,1040(a5) # 40011410 <__global_pointer$+0x20010c10>
20000122:	21e000e7          	jalr	542(zero) # 0 <InterruptVector>
20000126:	4532                	lw	a0,12(sp)
20000128:	47a2                	lw	a5,8(sp)
2000012a:	40012637          	lui	a2,0x40012
2000012e:	40062703          	lw	a4,1024(a2) # 40012400 <__global_pointer$+0x20011c00>
20000132:	40060693          	addi	a3,a2,1024
20000136:	8b09                	andi	a4,a4,2
20000138:	db7d                	beqz	a4,2000012e <ReadTouchPin.constprop.0+0x12e>
2000013a:	4602                	lw	a2,0(sp)
2000013c:	c62a                	sw	a0,12(sp)
2000013e:	40011737          	lui	a4,0x40011
20000142:	40c72023          	sw	a2,1024(a4) # 40011400 <__global_pointer$+0x20010c00>
20000146:	02000613          	li	a2,32
2000014a:	40c72823          	sw	a2,1040(a4)
2000014e:	46f0                	lw	a2,76(a3)
20000150:	97b2                	add	a5,a5,a2
20000152:	c43e                	sw	a5,8(sp)
		INNER_LOOP( 4 );
20000154:	210000e7          	jalr	528(zero) # 0 <InterruptVector>
20000158:	e000f637          	lui	a2,0xe000f
2000015c:	00862283          	lw	t0,8(a2) # e000f008 <__global_pointer$+0xc000e808>
20000160:	0032f613          	andi	a2,t0,3
20000164:	0606                	slli	a2,a2,0x1
20000166:	0631                	addi	a2,a2,12
20000168:	00000597          	auipc	a1,0x0
2000016c:	962e                	add	a2,a2,a1
2000016e:	001600e7          	jalr	1(a2)
20000172:	0001                	nop
20000174:	0001                	nop
20000176:	0001                	nop
20000178:	0001                	nop
2000017a:	400127b7          	lui	a5,0x40012
2000017e:	4097a423          	sw	s1,1032(a5) # 40012408 <__global_pointer$+0x20011c08>
20000182:	0001                	nop
20000184:	0001                	nop
20000186:	0001                	nop
20000188:	0001                	nop
2000018a:	40011737          	lui	a4,0x40011
2000018e:	40872023          	sw	s0,1024(a4) # 40011400 <__global_pointer$+0x20010c00>
20000192:	400117b7          	lui	a5,0x40011
20000196:	00200737          	lui	a4,0x200
2000019a:	40e7a823          	sw	a4,1040(a5) # 40011410 <__global_pointer$+0x20010c10>
2000019e:	21e000e7          	jalr	542(zero) # 0 <InterruptVector>
200001a2:	4532                	lw	a0,12(sp)
200001a4:	47a2                	lw	a5,8(sp)
200001a6:	400126b7          	lui	a3,0x40012
200001aa:	4006a703          	lw	a4,1024(a3) # 40012400 <__global_pointer$+0x20011c00>
200001ae:	40068613          	addi	a2,a3,1024
200001b2:	8b09                	andi	a4,a4,2
200001b4:	db7d                	beqz	a4,200001aa <ReadTouchPin.constprop.0+0x1aa>
200001b6:	4582                	lw	a1,0(sp)
200001b8:	40011737          	lui	a4,0x40011
200001bc:	40070693          	addi	a3,a4,1024 # 40011400 <__global_pointer$+0x20010c00>
200001c0:	40b72023          	sw	a1,1024(a4)
200001c4:	02000713          	li	a4,32
200001c8:	ca98                	sw	a4,16(a3)
200001ca:	4678                	lw	a4,76(a2)
200001cc:	97ba                	add	a5,a5,a4
200001ce:	953e                	add	a0,a0,a5
200001d0:	4792                	lw	a5,4(sp)
200001d2:	17fd                	addi	a5,a5,-1
200001d4:	c23e                	sw	a5,4(sp)
	for( i = 0; i < iterations; i++ )
200001d6:	e8079be3          	bnez	a5,2000006c <ReadTouchPin.constprop.0+0x6c>
	}

	return ret;
}
200001da:	40e2                	lw	ra,24(sp)
200001dc:	4452                	lw	s0,20(sp)
200001de:	44c2                	lw	s1,16(sp)
200001e0:	0171                	addi	sp,sp,28
200001e2:	8082                	ret
200001e4:	0000                	unimp
	...
